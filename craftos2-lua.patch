diff --git a/.gitignore b/.gitignore
index a8af28a..0e82938 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,7 @@
 *.o
 *.a
 *.orig
+*.rej
 *.lib
 *.dll
 *.pdb
diff --git a/include/lauxlib.h b/include/lauxlib.h
index a0593be..dad74c1 100644
--- a/include/lauxlib.h
+++ b/include/lauxlib.h
@@ -17,9 +17,11 @@
 
 #if defined(LUA_COMPAT_GETN)
 LUALIB_API int (luaL_getn) (lua_State *L, int t);
+LUALIB_API int (luaL_igetn) (lua_State *L, int t, int ictx);
 LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
 #else
 #define luaL_getn(L,i)          ((int)lua_objlen(L, i))
+#define luaL_igetn(L,i,c)       ((int)lua_objlen(L, i))
 #define luaL_setn(L,i,j)        ((void)0)  /* no op! */
 #endif
 
@@ -40,9 +42,11 @@ typedef struct luaL_Reg {
 
 
 LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
-                                const luaL_Reg *l, int nup);
+                                const luaL_Reg *l, int nup, int ftype);
 LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                 const luaL_Reg *l);
+LUALIB_API void (luaL_register_light) (lua_State *L, const char *libname,
+                                const luaL_Reg *l);                                
 LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
 LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
 LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
@@ -50,7 +54,7 @@ LUALIB_API int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
 LUALIB_API int (luaL_argerror_)(lua_State *L, int numarg, const char *extramsg);
 LUALIB_API const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                           size_t *l);
-LUALIB_API const char *(luaL_checkstring_) (lua_State *L, int numArg);
+LUALIB_API const char *(luaL_checkstring_)(lua_State *L, int numArg);
 LUALIB_API const char *(luaL_optlstring) (lua_State *L, int numArg,
                                           const char *def, size_t *l);
 LUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int numArg);
@@ -65,6 +69,7 @@ LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
 LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
 LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
 LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+LUALIB_API void (luaL_checkanyfunction) (lua_State *L, int narg);
 
 LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
 LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
diff --git a/include/lua.h b/include/lua.h
index 334b2c7..7541fd2 100644
--- a/include/lua.h
+++ b/include/lua.h
@@ -8,6 +8,7 @@
 
 #ifndef lua_h
 #define lua_h
+#define CRAFTOS2_LUA
 
 #include <stdarg.h>
 #include <stddef.h>
@@ -74,15 +75,15 @@ typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
 
 #define LUA_TNIL		0
 #define LUA_TBOOLEAN		1
-#define LUA_TLIGHTUSERDATA	2
-#define LUA_TNUMBER		3
-#define LUA_TSTRING		4
-#define LUA_TTABLE		5
-#define LUA_TFUNCTION		6
-#define LUA_TUSERDATA		7
-#define LUA_TTHREAD		8
-
-
+#define LUA_TROTABLE  2
+#define LUA_TLIGHTFUNCTION  3
+#define LUA_TLIGHTUSERDATA	4
+#define LUA_TNUMBER		5
+#define LUA_TSTRING		6
+#define LUA_TTABLE		7
+#define LUA_TFUNCTION		8
+#define LUA_TUSERDATA		9
+#define LUA_TTHREAD		10
 
 /* minimum Lua stack available to a C function */
 #define LUA_MINSTACK	20
@@ -170,6 +171,8 @@ LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
 LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
 LUA_API void  (lua_pushboolean) (lua_State *L, int b);
 LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API void  (lua_pushlightfunction) (lua_State *L, void *p);
+LUA_API void  (lua_pushrotable) (lua_State *L, void *p);
 LUA_API int   (lua_pushthread) (lua_State *L);
 
 
@@ -242,6 +245,8 @@ LUA_API int  (lua_status) (lua_State *L);
 #define LUA_GCSTEP		5
 #define LUA_GCSETPAUSE		6
 #define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMEMLIMIT	8
+#define LUA_GCGETMEMLIMIT	9
 
 LUA_API int (lua_gc) (lua_State *L, int what, int data);
 
@@ -266,7 +271,6 @@ LUA_API void  (lua_externalerror) (lua_State *L, const char * message); /* throw
 LUA_API void  (lua_setlockstate) (lua_State *L, int enabled); /* enables/disables lua_lock */
 
 
-
 /* 
 ** ===============================================================
 ** some useful macros
@@ -284,6 +288,7 @@ LUA_API void  (lua_setlockstate) (lua_State *L, int enabled); /* enables/disable
 #define lua_strlen(L,i)		lua_objlen(L, (i))
 
 #define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_islightfunction(L,n) (lua_type(L, (n)) == LUA_TLIGHTFUNCTION)
 #define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
 #define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
 #define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
diff --git a/include/luaconf.h b/include/luaconf.h
index 6423bfe..c7a9d0c 100644
--- a/include/luaconf.h
+++ b/include/luaconf.h
@@ -370,6 +370,16 @@
 
 
 
+/*
+@@ LUA_STRESS_EMERGENCY_GC enables stress testing code for the Emergency GC.
+** CHANGE it to defined if you want to test for Emergency GC related bugs.
+** Note that this will make the Lua vm very slow, since it will force a
+** full GC on every new allocation.
+*/
+#undef LUA_STRESS_EMERGENCY_GC
+
+
+
 /*
 @@ luai_apicheck is the assert macro used by the Lua-C API.
 ** CHANGE luai_apicheck if you want Lua to perform some checks in the
@@ -759,7 +769,22 @@ union luai_Cast { double l_d; long l_l; };
 ** without modifying the main part of the file.
 */
 
+#define LUA_MAX_ROTABLE_NAME      32
+
+/* LUA_OPTIMIZE_MEMORY:
+   0 - no optimizations
+   1 - optimize while maitaining full compatibility with the test suite
+   2 - aggresive optimizations (breaks compatibility with some tests)
+*/
+#ifndef LUA_OPTIMIZE_MEMORY
+#define LUA_OPTIMIZE_MEMORY				2
+#endif
+
+#if LUA_OPTIMIZE_MEMORY == 2 && LUA_USE_POPEN
+#error "Pipes not supported in aggresive optimization mode (LUA_OPTIMIZE_MEMORY=2)"
+#endif
 
+#define LUA_OPTIMIZE_DEBUG 3
 
 #endif
 
diff --git a/src/Makefile b/src/Makefile
index 8fd4fa4..ab49be6 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -32,10 +32,10 @@ LIB_O=	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o \
 	lstrlib.o loadlib.o linit.o lutf8lib.o lbitlib.o
 
 LUA_T=	lua
-LUA_O=	lua.o
+LUA_O=	lua.o ltests.o
 
 LUAC_T=	luac
-LUAC_O=	luac.o print.o
+LUAC_O=	luac.o print.o ltests.o
 
 ALL_O= $(CORE_O) $(LIB_O) $(LUA_O) $(LUAC_O)
 ALL_T= $(LUA_A)
@@ -131,8 +131,8 @@ emscripten:
 lapi.o: lapi.c lua.h luaconf.h lapi.h lobject.h llimits.h ldebug.h \
   lstate.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h \
   lundump.h lvm.h
-lauxlib.o: lauxlib.c lua.h luaconf.h lauxlib.h
-lbaselib.o: lbaselib.c lua.h luaconf.h lauxlib.h lualib.h
+lauxlib.o: lauxlib.c lua.h luaconf.h lauxlib.h lrotable.h
+lbaselib.o: lbaselib.c lua.h luaconf.h lauxlib.h lualib.h lrotable.h
 lcode.o: lcode.c lua.h luaconf.h lcode.h llex.h lobject.h llimits.h \
   lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h ldo.h lgc.h \
   ltable.h
@@ -149,14 +149,14 @@ lfunc.o: lfunc.c lua.h luaconf.h lfunc.h lobject.h llimits.h lgc.h lmem.h \
   lstate.h ltm.h lzio.h
 lgc.o: lgc.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h ltm.h \
   lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
-linit.o: linit.c lua.h luaconf.h lualib.h lauxlib.h
-liolib.o: liolib.c lua.h luaconf.h lauxlib.h lualib.h
+linit.o: linit.c lua.h luaconf.h lualib.h lauxlib.h lrotable.h
+liolib.o: liolib.c lua.h luaconf.h lauxlib.h lualib.h lrotable.h
 llex.o: llex.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h ltm.h \
   lzio.h lmem.h llex.h lparser.h lstring.h lgc.h ltable.h
-lmathlib.o: lmathlib.c lua.h luaconf.h lauxlib.h lualib.h
+lmathlib.o: lmathlib.c lua.h luaconf.h lauxlib.h lualib.h lrotable.h
 lmem.o: lmem.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h
-loadlib.o: loadlib.c lua.h luaconf.h lauxlib.h lualib.h
+loadlib.o: loadlib.c lua.h luaconf.h lauxlib.h lualib.h lrotable.h
 lobject.o: lobject.c lua.h luaconf.h ldo.h lobject.h llimits.h lstate.h \
   ltm.h lzio.h lmem.h lstring.h lgc.h lvm.h
 lopcodes.o: lopcodes.c lopcodes.h llimits.h lua.h luaconf.h
@@ -168,7 +168,7 @@ lstate.o: lstate.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h llex.h lstring.h ltable.h
 lstring.o: lstring.c lua.h luaconf.h lmem.h llimits.h lobject.h lstate.h \
   ltm.h lzio.h lstring.h lgc.h
-lstrlib.o: lstrlib.c lua.h luaconf.h lauxlib.h lualib.h
+lstrlib.o: lstrlib.c lua.h luaconf.h lauxlib.h lualib.h lrotable.h
 ltable.o: ltable.c lua.h luaconf.h ldebug.h lstate.h lobject.h llimits.h \
   ltm.h lzio.h lmem.h ldo.h lgc.h ltable.h
 ltablib.o: ltablib.c lua.h luaconf.h lauxlib.h lualib.h
diff --git a/src/lapi.c b/src/lapi.c
index ffc6fa1..686ef7a 100644
--- a/src/lapi.c
+++ b/src/lapi.c
@@ -22,6 +22,7 @@
 #include "lgc.h"
 #include "lmem.h"
 #include "lobject.h"
+#include "lrotable.h"
 #include "lstate.h"
 #include "lstring.h"
 #include "ltable.h"
@@ -61,12 +62,13 @@ static TValue *index2adr (lua_State *L, int idx) {
     case LUA_REGISTRYINDEX: return registry(L);
     case LUA_ENVIRONINDEX: {
       Closure *func = curr_func(L);
-      sethvalue(L, &L->env, func->c.env);
+      sethvalue(L, &L->env, func ? func->c.env : hvalue(gt(L)));
       return &L->env;
     }
     case LUA_GLOBALSINDEX: return gt(L);
     default: {
       Closure *func = curr_func(L);
+      if (!func) return cast(TValue *, luaO_nilobject);
       idx = LUA_GLOBALSINDEX - idx;
       return (idx <= func->c.nupvalues)
                 ? &func->c.upvalue[idx-1]
@@ -81,7 +83,7 @@ static Table *getcurrenv (lua_State *L) {
     return hvalue(gt(L));  /* use global table as environment */
   else {
     Closure *func = curr_func(L);
-    return func->c.env;
+    return func ? func->c.env : hvalue(gt(L));
   }
 }
 
@@ -215,13 +217,17 @@ LUA_API void lua_replace (lua_State *L, int idx) {
   api_checkvalidindex(L, o);
   if (idx == LUA_ENVIRONINDEX) {
     Closure *func = curr_func(L);
-    api_check(L, ttistable(L->top - 1)); 
-    func->c.env = hvalue(L->top - 1);
-    luaC_barrier(L, func, L->top - 1);
+    if (!func)
+      luaG_runerror(L, "attempt to set environment on lightfunction");
+    else {
+      api_check(L, ttistable(L->top - 1)); 
+      func->c.env = hvalue(L->top - 1);
+      luaC_barrier(L, func, L->top - 1);
+    }
   }
   else {
     setobj(L, o, L->top - 1);
-    if (idx < LUA_GLOBALSINDEX)  /* function upvalue? */
+    if (curr_func(L) && idx < LUA_GLOBALSINDEX)  /* function upvalue? */
       luaC_barrier(L, curr_func(L), L->top - 1);
   }
   L->top--;
@@ -441,6 +447,9 @@ LUA_API const void *lua_topointer (lua_State *L, int idx) {
     case LUA_TUSERDATA:
     case LUA_TLIGHTUSERDATA:
       return lua_touserdata(L, idx);
+    case LUA_TROTABLE: 
+    case LUA_TLIGHTFUNCTION:
+      return pvalue(o);
     default: return NULL;
   }
 }
@@ -549,6 +558,20 @@ LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {
   lua_unlock(L);
 }
 
+LUA_API void lua_pushrotable (lua_State *L, void *p) {
+  lua_lock(L);
+  setrvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
+LUA_API void lua_pushlightfunction(lua_State *L, void *p) {
+  lua_lock(L);
+  setfvalue(L->top, p);
+  api_incr_top(L);
+  lua_unlock(L);
+}
+
 
 LUA_API int lua_pushthread (lua_State *L) {
   lua_lock(L);
@@ -583,7 +606,9 @@ LUA_API void lua_getfield (lua_State *L, int idx, const char *k) {
   lua_lock(L);
   t = index2adr(L, idx);
   api_checkvalidindex(L, t);
+  fixedstack(L);
   setsvalue(L, &key, luaS_new(L, k));
+  unfixedstack(L);
     notresumable(L,
     luaV_gettable(L, t, &key, L->top);
   )
@@ -697,16 +722,16 @@ LUA_API void lua_settable (lua_State *L, int idx) {
 
 LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {
   StkId t;
-  TValue key;
   lua_lock(L);
   api_checknelems(L, 1);
   t = index2adr(L, idx);
   api_checkvalidindex(L, t);
-  setsvalue(L, &key, luaS_new(L, k));
+  setsvalue2s(L, L->top, luaS_new(L, k));
+  api_incr_top(L);
   notresumable(L,
-    luaV_settable(L, t, &key, L->top - 1);
+    luaV_settable(L, t, L->top - 1, L->top - 2);
   )
-  L->top--;  /* pop value */
+  L->top -= 2;  /* pop key and value */
   lua_unlock(L);
 }
 
@@ -717,7 +742,9 @@ LUA_API void lua_rawset (lua_State *L, int idx) {
   api_checknelems(L, 2);
   t = index2adr(L, idx);
   api_check(L, ttistable(t));
+  fixedstack(L);
   setobj2t(L, luaH_set(L, hvalue(t), L->top-2), L->top-1);
+  unfixedstack(L);
   luaC_barriert(L, hvalue(t), L->top-1);
   L->top -= 2;
   lua_unlock(L);
@@ -730,7 +757,9 @@ LUA_API void lua_rawseti (lua_State *L, int idx, int n) {
   api_checknelems(L, 1);
   o = index2adr(L, idx);
   api_check(L, ttistable(o));
+  fixedstack(L);
   setobj2t(L, luaH_setnum(L, hvalue(o), n), L->top-1);
+  unfixedstack(L);
   luaC_barriert(L, hvalue(o), L->top-1);
   L->top--;
   lua_unlock(L);
@@ -922,6 +951,7 @@ LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
   if (!chunkname) chunkname = "?";
   luaZ_init(L, &z, reader, data);
   status = luaD_protectedparser(L, &z, chunkname);
+  luaC_fullgc(L);
   lua_unlock(L);
   return status;
 }
@@ -958,11 +988,11 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
   g = G(L);
   switch (what) {
     case LUA_GCSTOP: {
-      g->GCthreshold = MAX_LUMEM;
+      set_block_gc(L);
       break;
     }
     case LUA_GCRESTART: {
-      g->GCthreshold = g->totalbytes;
+      unset_block_gc(L);
       break;
     }
     case LUA_GCCOLLECT: {
@@ -979,6 +1009,10 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
       break;
     }
     case LUA_GCSTEP: {
+      if(is_block_gc(L)) {
+        res = 1; /* gc is block so we need to pretend that the collection cycle finished. */
+        break;
+      }
       lu_mem a = (cast(lu_mem, data) << 10);
       if (a <= g->totalbytes)
         g->GCthreshold = g->totalbytes - a;
@@ -1003,6 +1037,24 @@ LUA_API int lua_gc (lua_State *L, int what, int data) {
       g->gcstepmul = data;
       break;
     }
+    case LUA_GCSETMEMLIMIT: {
+      /* GC values are expressed in Kbytes: #bytes/2^10 */
+      lu_mem new_memlimit = (cast(lu_mem, data) << 10);
+      if(new_memlimit > 0 && new_memlimit < g->totalbytes) {
+        /* run a full GC to make totalbytes < the new limit. */
+        luaC_fullgc(L);
+        if(new_memlimit < g->totalbytes)
+          new_memlimit = (g->totalbytes + 1024) & ~(1024-1); /* round up to next multiple of 1024 */
+      }
+      g->memlimit = new_memlimit;
+      /* new memlimit might be > then requested memlimit. */
+      res = cast_int(new_memlimit >> 10);
+      break;
+    }
+    case LUA_GCGETMEMLIMIT: {
+      res = cast_int(g->memlimit >> 10);
+      break;
+    }
     default: res = -1;  /* invalid option */
   }
   lua_unlock(L);
@@ -1029,10 +1081,39 @@ LUA_API int lua_error (lua_State *L) {
 LUA_API int lua_next (lua_State *L, int idx) {
   StkId t;
   int more;
+  luaR_table *rotab;
+  const char * key;
   lua_lock(L);
   t = index2adr(L, idx);
-  api_check(L, ttistable(t));
-  more = luaH_next(L, hvalue(t), L->top - 1);
+  api_check(L, ttistable(t) || ttisrotable(t));
+  if (ttisrotable(t)) {
+    rotab = (luaR_table*)rvalue(t);
+    if (!ttisstring(L->top - 1)) {
+      /* rotables only contain string keys */
+      more = 0;
+    } else {
+      key = svalue(L->top - 1);
+      /* search functions */
+      for (more = 0; rotab->pfuncs[more].name && strcmp(key, rotab->pfuncs[more].name) != 0; more++);
+      if (!rotab->pfuncs[more].name) {
+        /* if no more functions, search values */
+        for (more = 0; rotab->pvalues[more].name && strcmp(key, rotab->pvalues[more].name) != 0; more++);
+        if (!rotab->pvalues[more].name) {
+          /* no more elements */
+          more = 0;
+        } else {
+          setsvalue(L, L->top - 1, luaS_newlstr(L, rotab->pvalues[more].name, strlen(rotab->pvalues[more].name)));
+          setnvalue(L->top, rotab->pvalues[more].value)
+          more = 1;
+        }
+      } else {
+        setsvalue(L, L->top - 1, luaS_newlstr(L, rotab->pfuncs[more].name, strlen(rotab->pfuncs[more].name)));
+        setfvalue(L->top, rotab->pfuncs[more].func);
+        more = 1;
+      }
+    }
+  } else
+    more = luaH_next(L, hvalue(t), L->top - 1);
   if (more) {
     api_incr_top(L);
   }
@@ -1144,7 +1225,7 @@ LUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {
 static UpVal **getupvalref (lua_State *L, int fidx, int n) {
   LClosure *f;
   StkId fi = index2adr(L, fidx);
-  api_check(L, ttisLclosure(fi)/*, "Lua function expected"*/);
+  //api_check(L, ttisLclosure(fi)/*, "Lua function expected"*/);
   f = &clvalue(fi)->l;
   api_check(L, (1 <= n && n <= f->p->sizeupvalues)/*, "invalid upvalue index"*/);
   return &f->upvals[n - 1];  /* get its upvalue pointer */
diff --git a/src/lauxlib.c b/src/lauxlib.c
index a70379e..62f1c6c 100644
--- a/src/lauxlib.c
+++ b/src/lauxlib.c
@@ -22,7 +22,13 @@
 
 #include "lua.h"
 
+#include "lrotable.h"
+
 #include "lauxlib.h"
+#include "lgc.h"
+#include "ldo.h"
+#include "lobject.h"
+#include "lstate.h"
 
 
 #define FREELIST_REF	0	/* free list of references */
@@ -32,6 +38,9 @@
 #define abs_index(L, i)		((i) > 0 || (i) <= LUA_REGISTRYINDEX ? (i) : \
 					lua_gettop(L) + (i) + 1)
 
+// Parameters for luaI_openlib
+#define LUA_USECCLOSURES          0
+#define LUA_USELIGHTFUNCTIONS     1
 
 /*
 ** {======================================================
@@ -183,10 +192,18 @@ LUALIB_API void luaL_checkstack (lua_State *L, int space, const char *mes) {
 
 
 LUALIB_API void luaL_checktype (lua_State *L, int narg, int t) {
-  if (lua_type(L, narg) != t)
+  if (lua_type(L, narg) != t && (t != LUA_TTABLE || lua_type(L, narg) != LUA_TROTABLE))
     tag_error(L, narg, t);
 }
 
+LUALIB_API void luaL_checkanyfunction (lua_State *L, int narg) {
+  if (lua_type(L, narg) != LUA_TFUNCTION && lua_type(L, narg) != LUA_TLIGHTFUNCTION) {
+    const char *msg = lua_pushfstring(L, "function expected, got %s",
+                                      luaL_typename(L, narg));
+    luaL_argerror(L, narg, msg);    
+  }
+}
+
 
 LUALIB_API void luaL_checkany (lua_State *L, int narg) {
   if (lua_type(L, narg) == LUA_TNONE)
@@ -273,9 +290,17 @@ LUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {
 
 LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                 const luaL_Reg *l) {
-  luaI_openlib(L, libname, l, 0);
+  luaI_openlib(L, libname, l, 0, LUA_USECCLOSURES);
 }
 
+LUALIB_API void (luaL_register_light) (lua_State *L, const char *libname,
+                                const luaL_Reg *l) {
+#if LUA_OPTIMIZE_MEMORY > 0                              
+  luaI_openlib(L, libname, l, 0, LUA_USELIGHTFUNCTIONS);
+#else
+  luaI_openlib(L, libname, l, 0, LUA_USECCLOSURES);
+#endif  
+}
 
 static int libsize (const luaL_Reg *l) {
   int size = 0;
@@ -285,7 +310,7 @@ static int libsize (const luaL_Reg *l) {
 
 
 LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
-                              const luaL_Reg *l, int nup) {
+                              const luaL_Reg *l, int nup, int ftype) {
   if (libname) {
     int size = libsize(l);
     /* check whether lib already exists */
@@ -307,7 +332,10 @@ LUALIB_API void luaI_openlib (lua_State *L, const char *libname,
     if (l->func == NULL) continue;
     for (i=0; i<nup; i++)  /* copy upvalues to the top */
       lua_pushvalue(L, -nup);
-    lua_pushcclosure(L, l->func, nup);
+    if (ftype == LUA_USELIGHTFUNCTIONS)
+      lua_pushlightfunction(L, l->func);
+    else
+      lua_pushcclosure(L, l->func, nup);
     lua_setfield(L, -(nup+2), l->name);
   }
   lua_pop(L, nup);  /* remove upvalues */
@@ -429,6 +457,15 @@ LUALIB_API const char *luaL_findtable (lua_State *L, int idx,
     lua_pushlstring(L, fname, e - fname);
     lua_rawget(L, -2);
     if (lua_isnil(L, -1)) {  /* no such field? */
+      /* Check for rotables */
+      if (idx == LUA_GLOBALSINDEX) {
+        lu_byte keytype;
+        luaR_findglobal(fname, &keytype);
+        if (keytype == LUA_TROTABLE) {
+          lua_pop(L, 2);
+          return fname;
+        }
+      }
       lua_pop(L, 1);  /* remove this nil */
       lua_createtable(L, 0, (*e == '.' ? 1 : szhint)); /* new table for field */
       lua_pushlstring(L, fname, e - fname);
@@ -689,15 +726,44 @@ LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s) {
 /* }====================================================== */
 
 
+static int l_check_memlimit(lua_State *L, size_t needbytes) {
+  global_State *g = G(L);
+  int cycle_count = 0;
+  lu_mem limit = g->memlimit - needbytes;
+  /* don't allow allocation if it requires more memory then the total limit. */
+  if (needbytes > g->memlimit) return 1;
+  /* make sure the GC is not disabled. */
+  if (!is_block_gc(L)) {
+    while (g->totalbytes >= limit) {
+      /* only allow the GC to finished atleast 1 full cycle. */
+      if (g->gcstate == GCSpause && ++cycle_count > 1) break;
+      luaC_step(L);
+    }
+  }
+  return (g->totalbytes >= limit) ? 1 : 0;
+}
+
+
 static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
-  (void)ud;
-  (void)osize;
+  lua_State *L = (lua_State *)ud;
+  void *nptr;
   if (nsize == 0) {
     free(ptr);
     return NULL;
   }
-  else
-    return realloc(ptr, nsize);
+  if(nsize > osize && L != NULL) {
+#if defined(LUA_STRESS_EMERGENCY_GC)
+    luaC_fullgc(L);
+#endif
+    if(G(L)->memlimit > 0 && l_check_memlimit(L, nsize - osize))
+      return NULL;
+  }
+  nptr = realloc(ptr, nsize);
+  if (nptr == NULL && L != NULL) {
+    luaC_fullgc(L); /* emergency full collection. */
+    nptr = realloc(ptr, nsize); /* try allocation again */
+  }
+  return nptr;
 }
 
 
@@ -711,6 +777,7 @@ static int panic (lua_State *L) {
 
 LUALIB_API lua_State *luaL_newstate (void) {
   lua_State *L = lua_newstate(l_alloc, NULL);
+  lua_setallocf(L, l_alloc, L); /* allocator need lua_State. */
   if (L) lua_atpanic(L, &panic);
   return L;
 }
diff --git a/src/lauxlib.h b/src/lauxlib.h
index 34bdfb7..dad74c1 100644
--- a/src/lauxlib.h
+++ b/src/lauxlib.h
@@ -42,9 +42,11 @@ typedef struct luaL_Reg {
 
 
 LUALIB_API void (luaI_openlib) (lua_State *L, const char *libname,
-                                const luaL_Reg *l, int nup);
+                                const luaL_Reg *l, int nup, int ftype);
 LUALIB_API void (luaL_register) (lua_State *L, const char *libname,
                                 const luaL_Reg *l);
+LUALIB_API void (luaL_register_light) (lua_State *L, const char *libname,
+                                const luaL_Reg *l);                                
 LUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
 LUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);
 LUALIB_API int (luaL_typerror) (lua_State *L, int narg, const char *tname);
@@ -67,6 +69,7 @@ LUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);
 LUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
 LUALIB_API void (luaL_checktype) (lua_State *L, int narg, int t);
 LUALIB_API void (luaL_checkany) (lua_State *L, int narg);
+LUALIB_API void (luaL_checkanyfunction) (lua_State *L, int narg);
 
 LUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);
 LUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);
diff --git a/src/lbaselib.c b/src/lbaselib.c
index 2260dfd..4699c74 100644
--- a/src/lbaselib.c
+++ b/src/lbaselib.c
@@ -18,8 +18,13 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
-
+#include "lrotable.h"
+#include "lobject.h"
+#include "lstate.h"
+#ifdef LUA_OPTIMIZE_DEBUG   
+#include "lfunc.h"
+#include "ldebug.h"
+#endif
 
 
 /*
@@ -197,9 +202,10 @@ static int luaB_gcinfo (lua_State *L) {
 
 static int luaB_collectgarbage (lua_State *L) {
   static const char *const opts[] = {"stop", "restart", "collect",
-    "count", "step", "setpause", "setstepmul", NULL};
+    "count", "step", "setpause", "setstepmul","setmemlimit","getmemlimit", NULL};
   static const int optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,
-    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL};
+    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCSETPAUSE, LUA_GCSETSTEPMUL,
+		LUA_GCSETMEMLIMIT,LUA_GCGETMEMLIMIT};
   int o = luaL_checkoption(L, 1, "collect", opts);
   int ex = luaL_optint(L, 2, 0);
   int res = lua_gc(L, optsnum[o], ex);
@@ -229,7 +235,7 @@ static int luaB_type (lua_State *L) {
 
 
 static int luaB_next (lua_State *L) {
-  luaL_checktype(L, 1, LUA_TTABLE);
+  if (lua_type(L, 1) != LUA_TTABLE && lua_type(L, 1) != LUA_TROTABLE) luaL_typerror(L, 1, "table");
   lua_settop(L, 2);  /* create a 2nd argument if there isn't one */
   if (lua_next(L, 1))
     return 2;
@@ -242,7 +248,7 @@ static int luaB_next (lua_State *L) {
 
 static int luaB_pairs (lua_State *L) {
   if (lua_icontext(L)) return 3;
-  luaL_checktype(L, 1, LUA_TTABLE);
+  if (lua_type(L, 1) != LUA_TTABLE && lua_type(L, 1) != LUA_TROTABLE) luaL_typerror(L, 1, "table");
   if (luaL_getmetafield(L, 1, "__pairs")) {
     luaL_checktype(L, -1, LUA_TFUNCTION);
     lua_pushvalue(L, 1);
@@ -300,6 +306,69 @@ static int luaB_loadfile (lua_State *L) {
 }
 
 
+#ifdef LUA_OPTIMIZE_DEBUG   
+/* stripdebug([level[, function]]).  
+ * level:    1 don't discard debug
+ *           2 discard Local and Upvalue debug info
+ *           3 discard Local, Upvalue and lineno debug info.
+ * function: Function to be stripped as per setfenv except 0 not permitted. 
+ * If no arguments then the current default setting is returned.
+ * If function is omitted, this is the default setting for future compiles
+ * The function returns an estimated integer count of the bytes stripped.
+ */
+static int luaB_stripdebug (lua_State *L) {
+  int level;
+
+  if (L->top == L->base) {
+    lua_pushlightuserdata(L, &luaG_stripdebug );
+    lua_gettable(L, LUA_REGISTRYINDEX);
+    if (lua_isnil(L, -1)) {
+      lua_pop(L, 1);
+      lua_pushinteger(L, LUA_OPTIMIZE_DEBUG);
+    }
+    return 1;
+  }
+  
+  level = luaL_checkint(L, 1); 
+  if ((level <= 0) || (level > 3)) luaL_argerror(L, 1, "must in range 1-3"); 
+
+  if (L->top == L->base + 1) {
+    /* Store the default level in the registry if no function parameter */ 
+    lua_pushlightuserdata(L, &luaG_stripdebug);
+    lua_pushinteger(L, level);
+    lua_settable(L, LUA_REGISTRYINDEX);
+    lua_settop(L,0); 
+    return 0;
+  }
+
+  if (level == 1) {
+    lua_settop(L,0); 
+    lua_pushinteger(L, 0);
+    return 1;
+  }
+
+  if (!lua_isfunction(L, 2)) {
+    int scope = luaL_checkint(L, 2);
+    if (scope > 0) {
+      /* if the function parameter is a +ve integer then climb to find function */
+      lua_Debug ar;
+      lua_pop(L, 1); /* pop level as getinfo will replace it by the function */ 
+      if (lua_getstack(L, scope, &ar)) {
+        lua_getinfo(L, "f", &ar);
+      }
+    }
+  }
+  
+  if(!lua_isfunction(L, 2) || lua_iscfunction(L, -1)) luaL_argerror(L, 2, "must be a Lua Function");   
+  // lua_lock(L);
+  Proto *f = clvalue(L->base + 1)->l.p;
+  // lua_unlock(L);
+  lua_settop(L,0); 
+  lua_pushinteger(L, luaG_stripdebug(L, f, level, 1));
+  return 1;
+}
+#endif
+
 /*
 ** Reader for generic `load' function: `lua_load' uses the
 ** stack for internal stuff, so the reader cannot change the
@@ -455,35 +524,60 @@ static int luaB_newproxy (lua_State *L) {
   return 1;
 }
 
+#ifdef LUA_OPTIMIZE_DEBUG
+#define STRIPDEBUG {"stripdebug", luaB_stripdebug},
+#else
+#define STRIPDEBUG 
+#endif
+
+#define LUA_BASE_FUNCLIST\
+  {"assert", luaB_assert},\
+  {"collectgarbage", luaB_collectgarbage},\
+  {"dofile", luaB_dofile},\
+  {"error", luaB_error},\
+  {"gcinfo", luaB_gcinfo},\
+  {"getfenv", luaB_getfenv},\
+  {"getmetatable", luaB_getmetatable},\
+  {"loadfile", luaB_loadfile},\
+  {"load", luaB_load},\
+  {"loadstring", luaB_loadstring},\
+  {"next", luaB_next},\
+  {"pcall", luaB_pcall},\
+  {"print", luaB_print},\
+  {"rawequal", luaB_rawequal},\
+  {"rawget", luaB_rawget},\
+  {"rawset", luaB_rawset},\
+  {"select", luaB_select},\
+  {"setfenv", luaB_setfenv},\
+  {"setmetatable", luaB_setmetatable},\
+  STRIPDEBUG\
+  {"tonumber", luaB_tonumber},\
+  {"tostring", luaB_tostring},\
+  {"type", luaB_type},\
+  {"unpack", luaB_unpack},\
+  {"xpcall", luaB_xpcall}
+
+#if LUA_OPTIMIZE_MEMORY != 2
+static const luaL_Reg base_funcs[] = {
+  LUA_BASE_FUNCLIST,
+  {NULL, NULL}
+};
+#else
+static const luaL_Reg base_realfuncs[] = {
+  LUA_BASE_FUNCLIST,
+  {NULL, NULL}
+};
+
+static int luaB_index(lua_State *L)
+{
+  return luaR_findfunction(L, base_realfuncs);
+}
 
 static const luaL_Reg base_funcs[] = {
-  {"assert", luaB_assert},
-  {"collectgarbage", luaB_collectgarbage},
-  {"dofile", luaB_dofile},
-  {"error", luaB_error},
-  {"gcinfo", luaB_gcinfo},
-  {"getfenv", luaB_getfenv},
-  {"getmetatable", luaB_getmetatable},
-  {"loadfile", luaB_loadfile},
-  {"load", luaB_load},
-  {"loadstring", luaB_loadstring},
-  {"next", luaB_next},
-  {"pcall", luaB_pcall},
-  {"print", luaB_print},
-  {"rawequal", luaB_rawequal},
-  {"rawget", luaB_rawget},
-  {"rawset", luaB_rawset},
-  {"select", luaB_select},
-  {"setfenv", luaB_setfenv},
-  {"setmetatable", luaB_setmetatable},
-  {"tonumber", luaB_tonumber},
-  {"tostring", luaB_tostring},
-  {"type", luaB_type},
-  {"unpack", luaB_unpack},
-  /*{"epcall", luaB_epcall},*/
-  {"xpcall", luaB_xpcall},
+  {"__index", luaB_index},
   {NULL, NULL}
 };
+#endif
 
 
 /*
@@ -643,7 +737,7 @@ static int luaB_corunning (lua_State *L) {
 }
 
 
-static const luaL_Reg co_funcs[] = {
+const luaL_Reg co_funcs[] = {
   {"create", luaB_cocreate},
   {"resume", luaB_coresume},
   {"running", luaB_corunning},
@@ -669,7 +763,11 @@ static void base_open (lua_State *L) {
   lua_pushvalue(L, LUA_GLOBALSINDEX);
   lua_setglobal(L, "_G");
   /* open lib into global table */
-  luaL_register(L, "_G", base_funcs);
+  luaL_register_light(L, "_G", base_funcs);
+#if LUA_OPTIMIZE_MEMORY == 2
+  lua_pushvalue(L, -1);
+  lua_setmetatable(L, -2);
+#endif
   lua_pushliteral(L, LUA_VERSION);
   lua_setglobal(L, "_VERSION");  /* set global _VERSION */
   /* `ipairs' and `pairs' need auxiliary functions as upvalues */
@@ -688,7 +786,11 @@ static void base_open (lua_State *L) {
 
 LUALIB_API int luaopen_base (lua_State *L) {
   base_open(L);
+#if LUA_OPTIMIZE_MEMORY == 0
   luaL_register(L, LUA_COLIBNAME, co_funcs);
   return 2;
+#else
+  return 1;
+#endif
 }
 
diff --git a/src/lcode.c b/src/lcode.c
index ce9f6e5..2f8f4dc 100644
--- a/src/lcode.c
+++ b/src/lcode.c
@@ -788,12 +788,93 @@ void luaK_posfix (FuncState *fs, BinOpr op, expdesc *e1, expdesc *e2) {
   }
 }
 
+#ifdef LUA_OPTIMIZE_DEBUG
+
+/*
+ * Attempted to write to last (null terminator) byte of lineinfo, so need
+ * to grow the lineinfo vector and extend the fill bytes 
+ */  
+unsigned char *growLineInfo(FuncState *fs) {
+  int i, oldsize = fs->packedlineinfoSize;
+  Proto *f = fs->f;
+  unsigned char *p, *r;
+
+  lua_assert(f->packedlineinfo==NULL || f->packedlineinfo[oldsize-1] == 0);
+  
+  /* using the macro results in a redundant if test, but what the hell */
+  luaM_growvector(fs->L, f->packedlineinfo, fs->packedlineinfoSize, fs->packedlineinfoSize, 
+                  unsigned char, MAX_INT, "code size overflow");
+  r = p = f->packedlineinfo + oldsize;
+  if (oldsize) *--r = INFO_FILL_BYTE;
+  i = fs->packedlineinfoSize - oldsize - 1;  
+  while (i--) *p++ = INFO_FILL_BYTE;
+  *p = 0;
+  return r;
+}
+
+static void generateInfoDeltaLine(FuncState *fs, int line) {
+  /* Handle first time through when lineinfo points is NULL */ 
+  unsigned char *p = fs->f->packedlineinfo ? lineInfoTop(fs) + 1 : growLineInfo(fs);
+#define addDLbyte(v) if (*p==0) p = growLineInfo(fs); *p++ = (v);
+  int delta = line - fs->lastline - 1;
+  if (delta) {
+    if (delta<0) {
+      delta = -delta - 1;
+      addDLbyte((INFO_DELTA_MASK|INFO_SIGN_MASK) | (delta & INFO_DELTA_6BITS));
+    } else {   
+      delta = delta - 1;
+      addDLbyte(INFO_DELTA_MASK | (delta & INFO_DELTA_6BITS));
+    }
+    delta >>= 6;
+    while (delta) {
+      addDLbyte(INFO_DELTA_MASK | (delta & INFO_DELTA_7BITS));
+      delta >>= 7;
+    }
+  }
+  addDLbyte(1);
+  fs->lastline = line;
+  fs->lastlineOffset = p - fs->f->packedlineinfo - 1;
+#undef addDLbyte
+}
+#endif
 
 void luaK_fixline (FuncState *fs, int line) {
+#ifdef LUA_OPTIMIZE_DEBUG
+  /* The fixup line can be the same as existing one and in this case there's nothing to do */
+  if (line != fs->lastline) { 
+    /* first remove the current line reference */
+    unsigned char *p = lineInfoTop(fs);
+    lua_assert(*p < 127);
+    if (*p >1) {     
+      (*p)--;    /* this is simply decrementing the last count a multi-PC line */
+    } else {
+      /* it's a bit more complicated if it's the 1st instruction on the line */
+      int delta = 0;
+      unsigned char code;
+      /* this logic handles <i/c> [1snnnnnnn [1nnnnnnn]*]? <i/c=1> */
+      *p-- = INFO_FILL_BYTE;
+      /* work backwards over the coded delta computing the delta */  
+      while ((code=*p) & INFO_DELTA_MASK) {
+        *p-- = INFO_FILL_BYTE;
+        if (*p & INFO_DELTA_MASK) {
+          delta = delta + ((code & INFO_DELTA_7BITS)<<7);
+        } else {
+          delta += (code & INFO_DELTA_6BITS) + 1;
+          if (code & INFO_SIGN_MASK) delta = -delta;
+        }
+      }
+      /* and reposition the FuncState lastline pointers at the previous instruction count */
+      fs->lastline-= delta + 1;
+      fs->lastlineOffset = p - fs->f->packedlineinfo; 
+    }
+    /* Then add the new line reference */
+    generateInfoDeltaLine(fs, line);
+  }
+#else
   fs->f->lineinfo[fs->pc - 1] = line;
+#endif
 }
 
-
 static int luaK_code (FuncState *fs, Instruction i, int line) {
   Proto *f = fs->f;
   dischargejpc(fs);  /* `pc' will change */
@@ -802,13 +883,28 @@ static int luaK_code (FuncState *fs, Instruction i, int line) {
                   MAX_INT, "code size overflow");
   f->code[fs->pc] = i;
   /* save corresponding line information */
+#ifdef LUA_OPTIMIZE_DEBUG
+  /* note that frst time fs->lastline==0 through, so the else branch is taken */
+  if (fs->pc == fs->lineinfoLastPC+1) { 
+    if (line == fs->lastline && f->packedlineinfo[fs->lastlineOffset] < INFO_MAX_LINECNT) {
+      f->packedlineinfo[fs->lastlineOffset]++;
+    } else {
+      generateInfoDeltaLine(fs, line); 
+    }
+  } else {
+    /* The last instruction is occasionally overwritten as part of branch optimisation*/
+    lua_assert(fs->pc == fs->lineinfoLastPC);  /* panic if its anything other than this !! */
+    luaK_fixline(fs,line);
+  }
+  fs->lineinfoLastPC = fs->pc;
+#else
   luaM_growvector(fs->L, f->lineinfo, fs->pc, f->sizelineinfo, int,
                   MAX_INT, "code size overflow");
   f->lineinfo[fs->pc] = line;
+#endif
   return fs->pc++;
 }
 
-
 int luaK_codeABC (FuncState *fs, OpCode o, int a, int b, int c) {
   lua_assert(getOpMode(o) == iABC);
   lua_assert(getBMode(o) != OpArgN || b == 0);
diff --git a/src/ldblib.c b/src/ldblib.c
index b4d54da..1a128ba 100644
--- a/src/ldblib.c
+++ b/src/ldblib.c
@@ -109,7 +109,7 @@ static int db_getinfo (lua_State *L) {
       return 1;
     }
   }
-  else if (lua_isfunction(L, arg+1)) {
+  else if (lua_isfunction(L, arg+1) || lua_islightfunction(L, arg+1)) {
     lua_pushfstring(L, ">%s", options);
     options = lua_tostring(L, -1);
     lua_pushvalue(L, arg+1);
@@ -285,7 +285,7 @@ static int db_sethook (lua_State *L) {
   }
   else {
     const char *smask = luaL_checkstring(L, arg+2);
-    luaL_checktype(L, arg+1, LUA_TFUNCTION);
+    luaL_checkanyfunction(L, arg+1);
     count = luaL_optint(L, arg+3, 0);
     func = hookf; mask = makemask(smask, count);
   }
@@ -426,7 +426,7 @@ static int db_upvaluejoin (lua_State *L) {
 }
 
 
-static luaL_Reg dblib[] = {
+luaL_Reg dblib[] = {
   {"debug", db_debug},
   {"getfenv", db_getfenv},
   {"gethook", db_gethook},
@@ -450,8 +450,12 @@ static luaL_Reg dblib[] = {
 
 
 LUALIB_API int luaopen_debug (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY > 0
+  return 0;
+#else
   luaL_register(L, LUA_DBLIBNAME, dblib);
   return 1;
+#endif
 }
 
 LUALIB_API void lualib_debug_ccpc_functions(void(*scm)(lua_State *L, int), lua_CFunction debug, lua_CFunction breakpoint, lua_CFunction unsetbreakpoint) {
diff --git a/src/ldebug.c b/src/ldebug.c
index fadde80..d06b4aa 100644
--- a/src/ldebug.c
+++ b/src/ldebug.c
@@ -156,8 +156,8 @@ LUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {
 }
 
 
-static void funcinfo (lua_Debug *ar, Closure *cl) {
-  if (cl->c.isC) {
+static void funcinfo (lua_Debug *ar, Closure *cl, void *plight) {
+  if (plight || cl->c.isC) {
     ar->source = "=[C]";
     ar->linedefined = -1;
     ar->lastlinedefined = -1;
@@ -182,34 +182,126 @@ static void info_tailcall (lua_Debug *ar) {
   ar->nups = 0;
 }
 
-
 static void collectvalidlines (lua_State *L, Closure *f) {
   if (f == NULL || f->c.isC) {
     setnilvalue(L->top);
   }
   else {
+  #  define INFO_FILL_BYTE   0x7F
+#  define INFO_DELTA_MASK  0x80
+#  define INFO_SIGN_MASK   0x40
+#  define INFO_DELTA_6BITS 0x3F
+#  define INFO_DELTA_7BITS 0x7F
+#  define INFO_MAX_LINECNT  126
+
     Table *t = luaH_new(L, 0, 0);
+#ifdef LUA_OPTIMIZE_DEBUG
+    int line = 0;
+    unsigned char *p = f->l.p->packedlineinfo;
+    if (p) {
+      for (; *p && *p != INFO_FILL_BYTE; ) {
+        if (*p & INFO_DELTA_MASK) { /* line delta */
+          int delta = *p & INFO_DELTA_6BITS;
+          unsigned char sign = *p++ & INFO_SIGN_MASK;
+          int shift;
+          for (shift = 6; *p & INFO_DELTA_MASK; p++, shift += 7) {
+            delta += (*p & INFO_DELTA_7BITS)<<shift;
+          }
+          line += sign ? -delta : delta+2;
+        } else {
+          line++;
+        }
+       p++;
+       setbvalue(luaH_setnum(L, t, line), 1);
+      }
+    }
+#else
     int *lineinfo = f->l.p->lineinfo;
     int i;
     for (i=0; i<f->l.p->sizelineinfo; i++)
       setbvalue(luaH_setnum(L, t, lineinfo[i]), 1);
+#endif
     sethvalue(L, L->top, t); 
   }
   incr_top(L);
 }
 
+#ifdef LUA_OPTIMIZE_DEBUG
+/* 
+ * This may seem expensive but this is only accessed frequently in traceexec
+ * and the while loop will be executed roughly half the number of non-blank
+ * source lines in the Lua function and these tend to be short.
+ */
+int luaG_getline (const Proto *f, int pc) {
+  int line = 0, thispc = 0, nextpc;
+  unsigned char *p;
+  
+  for (p = f->packedlineinfo; *p && *p != INFO_FILL_BYTE;) {
+    if (*p & INFO_DELTA_MASK) { /* line delta */
+      int delta = *p & INFO_DELTA_6BITS;
+      unsigned char sign = *p++ & INFO_SIGN_MASK;
+      int shift;
+      for (shift = 6; *p & INFO_DELTA_MASK; p++, shift += 7) {
+        delta += (*p & INFO_DELTA_7BITS)<<shift;
+      }
+      line += sign ? -delta : delta+2;
+    } else {
+      line++;
+    }
+    lua_assert(*p<127);
+    nextpc = thispc + *p++;  
+    if (thispc <= pc && pc < nextpc) {
+      return line;
+    }
+    thispc = nextpc;
+  }
+  lua_assert(0); 
+  return 0;
+}
+
+static int stripdebug (lua_State *L, Proto *f, int level) {
+  int len = 0, sizepackedlineinfo;
+  TString* dummy;
+  switch (level) {
+    case 3:
+      sizepackedlineinfo = strlen(cast(char *, f->packedlineinfo))+1;
+      f->packedlineinfo = luaM_freearray(L, f->packedlineinfo, sizepackedlineinfo, unsigned char);
+      len += sizepackedlineinfo;
+    case 2:
+      len += f->sizelocvars * (sizeof(struct LocVar) + sizeof(dummy->tsv) + sizeof(struct LocVar *));
+      f->locvars = luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
+      f->upvalues = luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
+      len += f->sizelocvars * (sizeof(struct LocVar) + sizeof(dummy->tsv) + sizeof(struct LocVar *)) +
+             f->sizeupvalues * (sizeof(dummy->tsv) + sizeof(TString *));
+      f->sizelocvars = 0;
+      f->sizeupvalues = 0;
+  }
+  return len;
+}
+
+/* This is a recursive function so it's stack size has been kept to a minimum! */
+LUAI_FUNC int luaG_stripdebug (lua_State *L, Proto *f, int level, int recv){
+  int len = 0, i;
+  if (recv != 0 && f->sizep != 0) {
+    for(i=0;i<f->sizep;i++) len += luaG_stripdebug(L, f->p[i], level, recv);
+  }
+  len += stripdebug (L, f, level);
+  return len;
+}
+#endif
+
 
 static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
-                    Closure *f, CallInfo *ci) {
+                    Closure *f, void *plight, CallInfo *ci) {
   int status = 1;
-  if (f == NULL) {
+  if (plight == NULL && f == NULL) {
     info_tailcall(ar);
     return status;
   }
   for (; *what; what++) {
     switch (*what) {
       case 'S': {
-        funcinfo(ar, f);
+        funcinfo(ar, f, plight);
         break;
       }
       case 'l': {
@@ -217,8 +309,8 @@ static int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,
         break;
       }
       case 'u': {
-        ar->nups = f->c.nupvalues;
-        if (f->c.isC) {
+        ar->nups = f ? f->c.nupvalues : 0;
+        if (!f || f->c.isC) {
           ar->isvararg = 1;
           ar->nparams = 0;
         }
@@ -250,23 +342,34 @@ LUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {
   int status;
   Closure *f = NULL;
   CallInfo *ci = NULL;
+  void *plight = NULL;
   lua_lock(L);
   if (*what == '>') {
     StkId func = L->top - 1;
-    luai_apicheck(L, ttisfunction(func));
+    luai_apicheck(L, ttisfunction(func) || ttislightfunction(func));
     what++;  /* skip the '>' */
-    f = clvalue(func);
+    if (ttisfunction(func))
+      f = clvalue(func);
+    else
+      plight = fvalue(func);
     L->top--;  /* pop function */
   }
   else if (ar->i_ci != 0) {  /* no tail call? */
     ci = L->base_ci + ar->i_ci;
-    lua_assert(ttisfunction(ci->func));
-    f = clvalue(ci->func);
+    lua_assert(ttisfunction(ci->func) || ttislightfunction(ci->func));
+    if (ttisfunction(ci->func))
+      f = clvalue(ci->func);
+    else
+      plight = fvalue(ci->func);
   }
-  status = auxgetinfo(L, what, ar, f, ci);
+  status = auxgetinfo(L, what, ar, f, plight, ci);
   if (strchr(what, 'f')) {
-    if (f == NULL) setnilvalue(L->top);
-    else setclvalue(L, L->top, f);
+    if (f != NULL) 
+      setclvalue(L, L->top, f)
+    else if (plight != NULL)
+      setfvalue(L->top, plight)
+    else
+      setnilvalue(L->top);
     incr_top(L);
   }
   if (strchr(what, 'L'))
@@ -296,7 +399,9 @@ static int precheck (const Proto *pt) {
   check(!(pt->is_vararg & VARARG_NEEDSARG) ||
               (pt->is_vararg & VARARG_HASARG));
   check(pt->sizeupvalues <= pt->nups);
+#ifndef LUA_OPTIMIZE_DEBUG
   check(pt->sizelineinfo == pt->sizecode || pt->sizelineinfo == 0);
+#endif
   check(pt->sizecode > 0 && GET_OPCODE(pt->code[pt->sizecode-1]) == OP_RETURN);
   return 1;
 }
diff --git a/src/ldebug.h b/src/ldebug.h
index 2a7d398..4f03f18 100644
--- a/src/ldebug.h
+++ b/src/ldebug.h
@@ -13,7 +13,19 @@
 
 #define pcRel(pc, p)	(cast(int, (pc) - (p)->code) - 1)
 
-#define getline(f,pc)	(((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+#ifdef LUA_OPTIMIZE_DEBUG
+#  include "lvm.h"
+#  define getline(f,pc) (((f)->packedlineinfo) ? luaG_getline((f), pc) : 0)
+#  define INFO_FILL_BYTE   0x7F
+#  define INFO_DELTA_MASK  0x80
+#  define INFO_SIGN_MASK   0x40
+#  define INFO_DELTA_6BITS 0x3F
+#  define INFO_DELTA_7BITS 0x7F
+#  define INFO_MAX_LINECNT  126
+#  define lineInfoTop(fs) ((fs)->f->packedlineinfo + (fs)->lastlineOffset)
+#else
+#  define getline(f,pc) (((f)->lineinfo) ? (f)->lineinfo[pc] : 0)
+#endif
 
 #define resethookcount(L)	(L->hookcount = L->basehookcount)
 
@@ -29,4 +41,9 @@ LUAI_FUNC void luaG_runerror (lua_State *L, const char *fmt, ...);
 LUAI_FUNC int luaG_checkcode (const Proto *pt);
 LUAI_FUNC int luaG_checkopenop (Instruction i);
 
+#ifdef LUA_OPTIMIZE_DEBUG
+LUAI_FUNC int luaG_getline (const Proto *f, int pc);
+LUAI_FUNC int luaG_stripdebug (lua_State *L, Proto *f, int level, int recv);
+#endif
+
 #endif
diff --git a/src/ldo.c b/src/ldo.c
index cd8d080..bfcf0f9 100644
--- a/src/ldo.c
+++ b/src/ldo.c
@@ -51,11 +51,13 @@ struct lua_longjmp {
 void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {
   switch (errcode) {
     case LUA_ERRMEM: {
-      setsvalue2s(L, oldtop, luaS_newliteral(L, MEMERRMSG));
+      ptrdiff_t oldtopr = savestack(L, oldtop);
+      setsvalue2s(L, restorestack(L, oldtopr), luaS_newliteral(L, MEMERRMSG));
       break;
     }
     case LUA_ERRERR: {
-      setsvalue2s(L, oldtop, luaS_newliteral(L, "error in error handling"));
+      ptrdiff_t oldtopr = savestack(L, oldtop);
+      setsvalue2s(L, restorestack(L, oldtopr), luaS_newliteral(L, "error in error handling"));
       break;
     }
     case LUA_ERREXC: {
@@ -98,7 +100,7 @@ static int call_errfunc (lua_State *L) {
   for (ci = L->ci; ci > L->base_ci && ci->errfunc == 0; ci--) ;
   if (ci->errfunc >= 2) {
     StkId errfunc = ci->base + (ci->errfunc - 2);
-    if (!ttisfunction(errfunc)) return LUA_ERRERR;
+    if (!ttisfunction(errfunc) && !ttislightfunction(errfunc)) return LUA_ERRERR;
     setobjs2s(L, L->top, L->top - 1);  /* move argument */
     setobjs2s(L, L->top - 1, errfunc);  /* push function */
     incr_top(L);
@@ -110,6 +112,8 @@ static int call_errfunc (lua_State *L) {
 
 void luaD_throw (lua_State *L, int errcode) {
   struct lua_longjmp *lj = L->errorJmp;
+  unfixedstack(L); /* make sure the fixedstack & block_gc flags get reset. */
+  unset_block_gc(L);
   if ((errcode >= LUA_ERRRUN && errcode <= LUA_ERREXC) && L->hookmask & LUA_MASKERROR)
     luaD_callhook(L, LUA_HOOKERROR, -1);
   if (lj) {
@@ -145,14 +149,17 @@ int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {
 static int f_continue (lua_State *L, void *ud) {
   ptrdiff_t stop_ci = (ptrdiff_t)ud;
   while (L->ci > restoreci(L, stop_ci) && !G(L)->haltstate) {  /* continue frames, top to bottom */
-    CClosure *cc = &ci_func(L->ci)->c;
+    Closure *cl = ci_func(L->ci);
     L->ci->errfunc = 0;
-    if (cc->isC) {  /* continue C function */
+    if (!cl || cl->c.isC) {  /* continue C function */
       int n;
       lua_assert(L->ctx != NULL);
       if (L->top > L->ci->top) L->ci->top = L->top;
       lua_unlock(L);
-      n = (*cc->f)(L);  /* (re-)call it */
+      if (ttislightfunction(L->ci->func))
+        n = ((lua_CFunction)fvalue(L->ci->func))(L);  /* (re-)call it */
+      else
+        n = (*cl->c.f)(L);  /* (re-)call it */
       lua_lock(L);
       if (n < 0) return LUA_YIELD;
       lua_assert(L->base + n <= L->top);
@@ -308,7 +315,9 @@ void luaD_callhook (lua_State *L, int event, int line) {
 static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
   int i;
   int nfixargs = p->numparams;
+#if defined(LUA_COMPAT_VARARG)
   Table *htab = NULL;
+#endif
   StkId base, fixed;
   for (; actual < nfixargs; ++actual)
     setnilvalue(L->top++);
@@ -319,10 +328,15 @@ static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
     luaC_checkGC(L);
     luaD_checkstack(L, p->maxstacksize);
     htab = luaH_new(L, nvar, 1);  /* create `arg' table */
+    sethvalue2s(L, L->top, htab); /* put table on stack */
+    incr_top(L);
+    fixedstack(L);
     for (i=0; i<nvar; i++)  /* put extra arguments into `arg' table */
-      setobj2n(L, luaH_setnum(L, htab, i+1), L->top - nvar + i);
+      setobj2n(L, luaH_setnum(L, htab, i+1), L->top - 1 - nvar + i);
+    unfixedstack(L);
     /* store counter in field `n' */
     setnvalue(luaH_setstr(L, htab, luaS_newliteral(L, "n")), cast_num(nvar));
+    L->top--; /* remove table from stack */
   }
 #endif
   /* move fixed parameters to final position */
@@ -332,11 +346,13 @@ static StkId adjust_varargs (lua_State *L, Proto *p, int actual) {
     setobjs2s(L, L->top++, fixed+i);
     setnilvalue(fixed+i);
   }
+#if defined(LUA_COMPAT_VARARG)
   /* add `arg' parameter */
   if (htab) {
     sethvalue(L, L->top++, htab);
     lua_assert(iswhite(obj2gco(htab)));
   }
+#endif
   return base;
 }
 
@@ -363,14 +379,15 @@ static StkId tryfuncTM (lua_State *L, StkId func) {
 
 
 int luaD_precall (lua_State *L, StkId func, int nresults) {
-  Closure *cl;
+  Closure *cl = NULL;
   ptrdiff_t funcr;
-  if (!ttisfunction(func)) /* `func' is not a function? */
+  if (!ttisfunction(func) && !ttislightfunction(func)) /* `func' is not a function? */
     func = tryfuncTM(L, func);  /* check the `function' tag method */
   funcr = savestack(L, func);
-  cl = clvalue(func);
+  if (ttisfunction(func))
+    cl = clvalue(func);
   L->ci->ctx = L->ctx;
-  if (!cl->l.isC) {  /* Lua function? prepare its call */
+  if (cl && !cl->l.isC) {  /* Lua function? prepare its call */
     CallInfo *ci;
     StkId st, base;
     Proto *p = cl->l.p;
@@ -411,7 +428,7 @@ int luaD_precall (lua_State *L, StkId func, int nresults) {
     CallInfo *ci;
     int n;
     luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */
-    if (cl->c.f == NULL) {  /* error if the function is NULL */
+    if (cl && cl->c.f == NULL) {  /* error if the function is NULL */
       luaG_runerror(L, "attempt to call invalid C function");
       return 0; /* prevent IntelliSense warnings */
     }
@@ -426,7 +443,10 @@ int luaD_precall (lua_State *L, StkId func, int nresults) {
     if (L->hookmask & LUA_MASKCALL)
       luaD_callhook(L, LUA_HOOKCALL, -1);
     lua_unlock(L);
-    n = (*cl->c.f)(L);  /* do the actual call */
+    if (ttisfunction(func))
+      n = (*cl->c.f)(L);  /* do the actual call */
+    else
+      n = ((lua_CFunction)fvalue(func))(L);  /* do the actual call */
     lua_lock(L);
     if (n < 0)  /* yielding? */
       return PCRYIELD;
@@ -572,7 +592,7 @@ static int resume_error (lua_State *L, const char *msg) {
       break;
     }
     pf = f_continue;
-    ud = (void *)(ptrdiff_t)0;  /* (void *)saveci(L, L->base_ci); */
+    ud = (void *)saveci(L, L->base_ci);
    }
   L->baseCcalls = L->nCcalls = ((old_nCcalls & ~7)) | LUA_NOYIELD | LUA_NOVPCALL;
   L->status = status;
@@ -614,6 +634,7 @@ static int f_parser (lua_State *L, void *ud) {
   int c = luaZ_lookahead(p->z);
   L->nCcalls |= (LUA_NOYIELD | LUA_NOVPCALL);  /* parser is not resumable */
   luaC_checkGC(L);
+  set_block_gc(L);  /* stop collector during parsing */
   tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
                                                              &p->buff, p->name);
   cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));
@@ -622,6 +643,7 @@ static int f_parser (lua_State *L, void *ud) {
     cl->l.upvals[i] = luaF_newupval(L);
   setclvalue(L, L->top, cl);
   incr_top(L);
+  unset_block_gc(L);
   return 0;
 }
 
diff --git a/src/ldump.c b/src/ldump.c
index acf4b12..68b6e49 100644
--- a/src/ldump.c
+++ b/src/ldump.c
@@ -16,6 +16,10 @@
 #include "lstate.h"
 #include "lundump.h"
 
+#ifdef LUA_OPTIMIZE_DEBUG
+#include <string.h>
+#endif
+
 typedef struct {
  lua_State* L;
  lua_Writer writer;
@@ -85,7 +89,10 @@ static void DumpConstants(const Proto* f, DumpState* D)
  for (i=0; i<n; i++)
  {
   const TValue* o=&f->k[i];
-  DumpChar(ttype(o),D);
+  char t = ttype(o);
+  if (t == LUA_TNUMBER) t = 3;
+  else if (t == LUA_TSTRING) t = 4;
+  DumpChar(t,D);
   switch (ttype(o))
   {
    case LUA_TNIL:
@@ -112,8 +119,25 @@ static void DumpConstants(const Proto* f, DumpState* D)
 static void DumpDebug(const Proto* f, DumpState* D)
 {
  int i,n;
+#ifdef LUA_OPTIMIZE_DEBUG
+ n = (D->strip || f->packedlineinfo == NULL) ? 0: strlen(cast(char *,f->packedlineinfo))+1;
+ DumpInt(n,D);
+//--eLua Align4(D);
+ if (n)
+  {
+  DumpBlock(f->packedlineinfo, n, D);
+  }
+#else
+//--eLua  n= (D->strip) ? 0 : f->sizelineinfo;
+//--eLua  DumpInt(n,D);
+//--eLua  Align4(D);
+//--eLua  for (i=0; i<n; i++)
+//--eLua  {
+//--eLua   DumpInt(f->lineinfo[i],D);
+//--eLua  }
  n= (D->strip) ? 0 : f->sizelineinfo;
  DumpVector(f->lineinfo,n,sizeof(int),D);
+#endif
  n= (D->strip) ? 0 : f->sizelocvars;
  DumpInt(n,D);
  for (i=0; i<n; i++)
diff --git a/src/lfunc.c b/src/lfunc.c
index 54d64e2..46fa92e 100644
--- a/src/lfunc.c
+++ b/src/lfunc.c
@@ -18,7 +18,9 @@
 #include "lobject.h"
 #include "lstate.h"
 
-
+#ifdef LUA_OPTIMIZE_DEBUG
+#include <string.h>
+#endif
 
 Closure *luaF_newCclosure (lua_State *L, int nelems, Table *e) {
   Closure *c = cast(Closure *, luaM_malloc(L, sizeCclosure(nelems)));
@@ -66,7 +68,6 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
   }
   uv = luaM_new(L, UpVal);  /* not found: create a new one */
   uv->tt = LUA_TUPVAL;
-  uv->marked = luaC_white(g);
   uv->v = level;  /* current value lives in the stack */
   uv->next = *pp;  /* chain it in the proper position */
   *pp = obj2gco(uv);
@@ -74,6 +75,7 @@ UpVal *luaF_findupval (lua_State *L, StkId level) {
   uv->u.l.next = g->uvhead.u.l.next;
   uv->u.l.next->u.l.prev = uv;
   g->uvhead.u.l.next = uv;
+  luaC_marknew(L, obj2gco(uv));
   lua_assert(uv->u.l.next->u.l.prev == uv && uv->u.l.prev->u.l.next == uv);
   return uv;
 }
@@ -121,19 +123,23 @@ Proto *luaF_newproto (lua_State *L) {
   f->sizep = 0;
   f->code = NULL;
   f->sizecode = 0;
-  f->sizelineinfo = 0;
   f->sizeupvalues = 0;
   f->nups = 0;
   f->upvalues = NULL;
   f->numparams = 0;
   f->is_vararg = 0;
   f->maxstacksize = 0;
-  f->lineinfo = NULL;
   f->sizelocvars = 0;
   f->locvars = NULL;
   f->linedefined = 0;
   f->lastlinedefined = 0;
   f->source = NULL;
+#ifdef LUA_OPTIMIZE_DEBUG
+  f->packedlineinfo = NULL;
+#else
+  f->lineinfo = NULL;
+  f->sizelineinfo = 0;
+#endif
   return f;
 }
 
@@ -142,7 +148,13 @@ void luaF_freeproto (lua_State *L, Proto *f) {
   luaM_freearray(L, f->code, f->sizecode, Instruction);
   luaM_freearray(L, f->p, f->sizep, Proto *);
   luaM_freearray(L, f->k, f->sizek, TValue);
+#ifdef LUA_OPTIMIZE_DEBUG
+  if (f->packedlineinfo) {
+    luaM_freearray(L, f->packedlineinfo, strlen(cast(char *, f->packedlineinfo))+1, unsigned char); 
+  }   
+#else
   luaM_freearray(L, f->lineinfo, f->sizelineinfo, int);
+#endif
   luaM_freearray(L, f->locvars, f->sizelocvars, struct LocVar);
   luaM_freearray(L, f->upvalues, f->sizeupvalues, TString *);
   luaM_free(L, f);
diff --git a/src/lgc.c b/src/lgc.c
index feefa3b..139fcae 100644
--- a/src/lgc.c
+++ b/src/lgc.c
@@ -232,8 +232,10 @@ static void traverseclosure (global_State *g, Closure *cl) {
     int i;
     lua_assert(cl->l.nupvalues == cl->l.p->nups);
     markobject(g, cl->l.p);
-    for (i=0; i<cl->l.nupvalues; i++)  /* mark its upvalues */
-      markobject(g, cl->l.upvals[i]);
+    for (i=0; i<cl->l.nupvalues; i++) { /* mark its upvalues */
+      if(cl->l.upvals[i])
+        markobject(g, cl->l.upvals[i]);
+    }
   }
 }
 
@@ -258,6 +260,7 @@ static void traversestack (global_State *g, lua_State *l) {
   CallInfo *ci;
   markvalue(g, gt(l));
   lim = l->top;
+  if(l->stack == NULL) return; /* no stack to traverse */
   for (ci = l->base_ci; ci <= l->ci; ci++) {
     lua_assert(ci->top <= l->stack_last);
     if (lim < ci->top) lim = ci->top;
@@ -266,7 +269,8 @@ static void traversestack (global_State *g, lua_State *l) {
     markvalue(g, o);
   for (; o <= lim; o++)
     setnilvalue(o);
-  checkstacksizes(l, lim);
+  if (!isfixedstack(l)) /* if stack size is fixed, can't resize it. */
+    checkstacksizes(l, lim);
 }
 
 
@@ -309,11 +313,16 @@ static l_mem propagatemark (global_State *g) {
       g->gray = p->gclist;
       traverseproto(g, p);
       return sizeof(Proto) + sizeof(Instruction) * p->sizecode +
+//--eLua                     (proto_is_readonly(p) ? 0 : sizeof(Instruction) * p->sizecode +
                              sizeof(Proto *) * p->sizep +
                              sizeof(TValue) * p->sizek + 
-                             sizeof(int) * p->sizelineinfo +
                              sizeof(LocVar) * p->sizelocvars +
-                             sizeof(TString *) * p->sizeupvalues;
+                             sizeof(TString *) * p->sizeupvalues +
+#ifdef LUA_OPTIMIZE_DEBUG
+                             (p->packedlineinfo ? strlen(cast(char *, p->packedlineinfo))+1 : 0);
+#else
+                             sizeof(int) * p->sizelineinfo;
+#endif
     }
     default: lua_assert(0); return 0;
   }
@@ -419,8 +428,6 @@ static GCObject **sweeplist (lua_State *L, GCObject **p, lu_mem count) {
     else {  /* must erase `curr' */
       lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));
       *p = curr->gch.next;
-      if (curr == g->rootgc)  /* is the first element of the list? */
-        g->rootgc = curr->gch.next;  /* adjust first */
       freeobj(L, curr);
     }
   }
@@ -434,6 +441,8 @@ static void checkSizes (lua_State *L) {
   if (g->strt.nuse < cast(lu_int32, g->strt.size/4) &&
       g->strt.size > MINSTRTABSIZE*2)
     luaS_resize(L, g->strt.size/2);  /* table is too big */
+  /* it is not safe to re-size the buffer if it is in use. */
+  if (luaZ_bufflen(&g->buff) > 0) return;
   /* check size of buffer */
   if (luaZ_sizebuffer(&g->buff) > LUA_MINBUFFER*2) {  /* buffer too big? */
     size_t newsize = luaZ_sizebuffer(&g->buff) / 2;
@@ -549,6 +558,15 @@ static void atomic (lua_State *L) {
   g->estimate = g->totalbytes - udsize;  /* first estimate */
 }
 
+static void sweepstrstep (global_State *g, lua_State *L) {
+  lu_mem old = g->totalbytes;
+  sweepwholelist(L, &g->strt.hash[g->sweepstrgc++]);
+  if (g->sweepstrgc >= g->strt.size)  /* nothing more to sweep? */
+    g->gcstate = GCSsweep;  /* end sweep-string phase */
+  lua_assert(old >= g->totalbytes);
+  g->estimate -= old - g->totalbytes;
+}
+
 
 static l_mem singlestep (lua_State *L) {
   global_State *g = G(L);
@@ -567,18 +585,13 @@ static l_mem singlestep (lua_State *L) {
       }
     }
     case GCSsweepstring: {
-      lu_mem old = g->totalbytes;
-      sweepwholelist(L, &g->strt.hash[g->sweepstrgc++]);
-      if (g->sweepstrgc >= g->strt.size)  /* nothing more to sweep? */
-        g->gcstate = GCSsweep;  /* end sweep-string phase */
-      lua_assert(old >= g->totalbytes);
-      g->estimate -= old - g->totalbytes;
+      sweepstrstep(g, L);
       return GCSWEEPCOST;
     }
     case GCSsweep: {
       lu_mem old = g->totalbytes;
       g->sweepgc = sweeplist(L, g->sweepgc, GCSWEEPMAX);
-      if (*g->sweepgc == NULL) {  /* nothing more to sweep? */
+      if (*g->sweepgc < (GCObject*)256) {  /* nothing more to sweep? */
         checkSizes(L);
         g->gcstate = GCSfinalize;  /* end sweep phase */
       }
@@ -606,10 +619,14 @@ static l_mem singlestep (lua_State *L) {
 
 void luaC_step (lua_State *L) {
   global_State *g = G(L);
+  if(is_block_gc(L)) return;
+  set_block_gc(L);
   l_mem lim = (GCSTEPSIZE/100) * g->gcstepmul;
   if (lim == 0)
     lim = (MAX_LUMEM-1)/2;  /* no limit */
   g->gcdept += g->totalbytes - g->GCthreshold;
+  if (g->estimate > g->totalbytes)
+    g->estimate = g->totalbytes;
   do {
     lim -= singlestep(L);
     if (g->gcstate == GCSpause)
@@ -626,11 +643,23 @@ void luaC_step (lua_State *L) {
   else {
     setthreshold(g);
   }
+  unset_block_gc(L);
 }
 
 
+int luaC_sweepstrgc (lua_State *L) {
+  global_State *g = G(L);
+  if (g->gcstate == GCSsweepstring) {
+    sweepstrstep(g, L);
+    return (g->gcstate == GCSsweepstring) ? 1 : 0;
+  }
+  return 0;
+}
+
 void luaC_fullgc (lua_State *L) {
   global_State *g = G(L);
+  if(is_block_gc(L)) return;
+  set_block_gc(L);
   if (g->gcstate <= GCSpropagate) {
     /* reset sweep marks to sweep all elements (returning them to white) */
     g->sweepstrgc = 0;
@@ -652,6 +681,7 @@ void luaC_fullgc (lua_State *L) {
     singlestep(L);
   }
   setthreshold(g);
+  unset_block_gc(L);
 }
 
 
@@ -687,13 +717,21 @@ void luaC_barrierback (lua_State *L, Table *t) {
 void luaC_upvalbarrier_ (lua_State *L, UpVal *uv) {
   global_State *g = G(L);
   GCObject *o = gcvalue(uv->v);
-  lua_assert(!upisopen(uv));  /* ensured by macro luaC_upvalbarrier */
+  //lua_assert(!upisopen(uv));  /* ensured by macro luaC_upvalbarrier */
   if (g->gcstate <= GCSpropagate)
     markobject(g, o);
 }
 
 
 
+void luaC_marknew (lua_State *L, GCObject *o) {
+  global_State *g = G(L);
+  o->gch.marked = luaC_white(g);
+  if (g->gcstate == GCSpropagate)
+    reallymarkobject(g, o);  /* mark new objects as gray during propagate state. */
+}
+
+
 void luaC_link (lua_State *L, GCObject *o, lu_byte tt) {
   global_State *g = G(L);
   o->gch.next = g->rootgc;
diff --git a/src/lgc.h b/src/lgc.h
index 3cfb6f4..8372102 100644
--- a/src/lgc.h
+++ b/src/lgc.h
@@ -37,12 +37,30 @@
 #define test2bits(x,b1,b2)	testbits(x, (bit2mask(b1, b2)))
 
 
+/*
+** Possible Garbage Collector flags.
+** Layout for bit use in 'gsflags' field in global_State structure.
+** bit 0 - Protect GC from recursive calls.
+** bit 1 - Don't try to shrink string table if EGC was called during a string table resize.
+*/
+#define GCFlagsNone          0
+#define GCBlockGCBit         0
+#define GCResizingStringsBit 1
+
+
+#define is_block_gc(L)    testbit(G(L)->gcflags, GCBlockGCBit)
+#define set_block_gc(L)   l_setbit(G(L)->gcflags, GCBlockGCBit)
+#define unset_block_gc(L) resetbit(G(L)->gcflags, GCBlockGCBit)
+#define is_resizing_strings_gc(L)    testbit(G(L)->gcflags, GCResizingStringsBit)
+#define set_resizing_strings_gc(L)   l_setbit(G(L)->gcflags, GCResizingStringsBit)
+#define unset_resizing_strings_gc(L) resetbit(G(L)->gcflags, GCResizingStringsBit)
 
 /*
 ** Layout for bit use in `marked' field:
 ** bit 0 - object is white (type 0)
 ** bit 1 - object is white (type 1)
 ** bit 2 - object is black
+** bit 3 - for thread: Don't resize thread's stack
 ** bit 3 - for userdata: has been finalized
 ** bit 3 - for tables: has weak keys
 ** bit 4 - for tables: has weak values
@@ -54,6 +72,7 @@
 #define WHITE0BIT	0
 #define WHITE1BIT	1
 #define BLACKBIT	2
+#define FIXEDSTACKBIT	3
 #define FINALIZEDBIT	3
 #define KEYWEAKBIT	3
 #define VALUEWEAKBIT	4
@@ -76,6 +95,9 @@
 
 #define luaC_white(g)	cast(lu_byte, (g)->currentwhite & WHITEBITS)
 
+#define isfixedstack(x)	testbit((x)->marked, FIXEDSTACKBIT)
+#define fixedstack(x)	l_setbit((x)->marked, FIXEDSTACKBIT)
+#define unfixedstack(x)	resetbit((x)->marked, FIXEDSTACKBIT)
 
 #define luaC_checkGC(L) { \
   condhardstacktests(luaD_reallocstack(L, L->stacksize - EXTRA_STACK - 1)); \
@@ -105,6 +127,8 @@ LUAI_FUNC void luaC_callGCTM (lua_State *L);
 LUAI_FUNC void luaC_freeall (lua_State *L);
 LUAI_FUNC void luaC_step (lua_State *L);
 LUAI_FUNC void luaC_fullgc (lua_State *L);
+LUAI_FUNC int luaC_sweepstrgc (lua_State *L);
+LUAI_FUNC void luaC_marknew (lua_State *L, GCObject *o);
 LUAI_FUNC void luaC_link (lua_State *L, GCObject *o, lu_byte tt);
 LUAI_FUNC void luaC_linkupval (lua_State *L, UpVal *uv);
 LUAI_FUNC void luaC_barrierf (lua_State *L, GCObject *o, GCObject *v);
diff --git a/src/linit.c b/src/linit.c
index a214434..ecf6f30 100644
--- a/src/linit.c
+++ b/src/linit.c
@@ -12,22 +12,78 @@
 
 #include "lualib.h"
 #include "lauxlib.h"
+#include "lrotable.h"
 
 
 static const luaL_Reg lualibs[] = {
   {"", luaopen_base},
-  {LUA_LOADLIBNAME, luaopen_package},
-  {LUA_TABLIBNAME, luaopen_table},
+  //{LUA_LOADLIBNAME, luaopen_package},
   {LUA_IOLIBNAME, luaopen_io},
-  {LUA_OSLIBNAME, luaopen_os},
   {LUA_STRLIBNAME, luaopen_string},
+#if LUA_OPTIMIZE_MEMORY == 0
   {LUA_MATHLIBNAME, luaopen_math},
-  {LUA_DBLIBNAME, luaopen_debug},
-  {LUA_UTF8LIBNAME, luaopen_utf8},
-  {LUA_BITLIBNAME, luaopen_bit32},
+  //{LUA_OSLIBNAME, luaopen_os},
+  {LUA_TABLIBNAME, luaopen_table},
+  //{LUA_DBLIBNAME, luaopen_debug},
+  //{LUA_UTF8LIBNAME, luaopen_utf8},
+  //{LUA_BITLIBNAME, luaopen_bit32},
+#endif
   {NULL, NULL}
 };
 
+/* The read-only tables are defined here */
+extern const luaL_Reg mathlib[];
+extern const luaR_value_entry mathlib_vals[];
+extern const luaL_Reg syslib[];
+extern const luaL_Reg tab_funcs[];
+extern const luaL_Reg dblib[];
+extern const luaL_Reg co_funcs[];
+extern const luaL_Reg bit_lib[];
+extern const luaL_Reg colors_funcs[];
+extern const luaR_value_entry colors_values[];
+extern const luaR_value_entry colours_values[];
+extern const luaL_Reg fs_lib[];
+extern const luaL_Reg help_lib[];
+extern const luaL_Reg keys_funcs[];
+extern const luaR_value_entry keys_values[];
+extern const luaL_Reg parallel_lib[];
+extern const luaL_Reg peripheral_lib[];
+extern const luaL_Reg rednet_funcs[];
+extern const luaL_Reg rs_lib[];
+extern const luaR_value_entry rednet_values[];
+extern const luaL_Reg settings_lib[];
+extern const luaL_Reg term_lib[];
+extern const luaL_Reg vector_lib[];
+extern const luaL_Reg vector_mt[];
+const luaR_table lua_rotable[] = 
+{
+#if LUA_OPTIMIZE_MEMORY > 0
+  {LUA_MATHLIBNAME, mathlib, mathlib_vals},
+  //{LUA_OSLIBNAME, syslib, NULL},
+  {LUA_TABLIBNAME, tab_funcs, NULL},
+  //{LUA_DBLIBNAME, dblib, NULL},
+  {LUA_COLIBNAME, co_funcs, NULL},
+  {"term", term_lib, NULL},
+  {"bit", bit_lib, NULL},
+  {"colors", colors_funcs, colors_values},
+  {"colours", colors_funcs, colours_values},
+  {"fs", fs_lib, NULL},
+  {"help", help_lib, NULL},
+  {"keys", keys_funcs, keys_values},
+  {"parallel", parallel_lib, NULL},
+  {"peripheral", peripheral_lib, NULL},
+  {"rednet", rednet_funcs, rednet_values},
+  {"redstone", rs_lib, NULL},
+  {"rs", rs_lib, NULL},
+  {"settings", settings_lib, NULL},
+  {"vector", vector_lib, NULL},
+#endif
+  {NULL, NULL, NULL}
+#if LUA_OPTIMIZE_MEMORY > 0
+  ,{"vector.mt", vector_mt, NULL}
+#endif
+};
+
 
 LUALIB_API void luaL_openlibs (lua_State *L) {
   const luaL_Reg *lib = lualibs;
@@ -37,4 +93,3 @@ LUALIB_API void luaL_openlibs (lua_State *L) {
     lua_call(L, 1, 0);
   }
 }
-
diff --git a/src/liolib.c b/src/liolib.c
index e1c9a44..50f3067 100644
--- a/src/liolib.c
+++ b/src/liolib.c
@@ -17,6 +17,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
+#include "lrotable.h"
 
 FILE* default_fopen(lua_State *L, const char * filename, const char * mode) {return fopen(filename, mode);}
 int default_fclose(lua_State *L, FILE * stream) {return fclose(stream);}
@@ -30,6 +31,16 @@ int (*mounter_fclose)(lua_State *L, FILE * stream) = &default_fclose;
 
 #define IO_INPUT	1
 #define IO_OUTPUT	2
+#define IO_STDERR	0
+#undef LUA_OPTIMIZE_MEMORY
+
+#if LUA_OPTIMIZE_MEMORY != 2
+#define LUA_IO_GETFIELD(f)	lua_rawgeti(L, LUA_ENVIRONINDEX, f)
+#define LUA_IO_SETFIELD(f)  lua_rawseti(L, LUA_ENVIRONINDEX, f)
+#else
+#define LUA_IO_GETFIELD(f)  lua_rawgeti(L, LUA_REGISTRYINDEX, liolib_keys[f]);  
+#define LUA_IO_SETFIELD(f)  lua_rawseti(L, LUA_REGISTRYINDEX, liolib_keys[f])
+#endif
 
 
 static const char *const fnames[] = {"input", "output"};
@@ -137,15 +148,28 @@ static int io_fclose (lua_State *L) {
 
 
 static int aux_close (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY != 2
   lua_getfenv(L, 1);
   lua_getfield(L, -1, "__close");
   return (lua_tocfunction(L, -1))(L);
+#else
+  FILE **p = tofilep(L);
+  if(*p == stdin || *p == stdout || *p == stderr)
+  {
+    lua_pushnil(L);
+    lua_pushliteral(L, "cannot close standard file");
+    return 2;  
+  }
+  int ok = (fclose(*p) == 0);
+  *p = NULL;
+  return pushresult(L, ok, NULL);
+#endif 
 }
 
 
 static int io_close (lua_State *L) {
   if (lua_isnone(L, 1))
-    lua_rawgeti(L, LUA_ENVIRONINDEX, IO_OUTPUT);
+    LUA_IO_GETFIELD(IO_OUTPUT);
   tofile(L);  /* make sure argument is a file */
   return aux_close(L);
 }
@@ -207,10 +231,10 @@ static int g_iofile (lua_State *L, int f, const char *mode) {
         lua_pushvalue(L, 1);
       }
     }
-    lua_rawseti(L, LUA_ENVIRONINDEX, f);
+    LUA_IO_SETFIELD(f);
   }
   /* return current value */
-  lua_rawgeti(L, LUA_ENVIRONINDEX, f);
+  LUA_IO_GETFIELD(f);
   return 1;
 }
 
diff --git a/src/llimits.h b/src/llimits.h
index 964ed5c..65e068a 100644
--- a/src/llimits.h
+++ b/src/llimits.h
@@ -106,10 +106,10 @@ typedef lu_int32 Instruction;
 #endif
 
 /* Use external C++ locks to help with multi-threading */
-extern void _lua_lock(lua_State *L);
+/*extern void _lua_lock(lua_State *L);
 extern void _lua_unlock(lua_State *L);
 #define lua_lock _lua_lock
-#define lua_unlock _lua_unlock
+#define lua_unlock _lua_unlock*/
 
 #ifndef lua_lock
 #define lua_lock(L)     ((void) 0) 
diff --git a/src/lmathlib.c b/src/lmathlib.c
index dd28bd9..dbb1ff6 100644
--- a/src/lmathlib.c
+++ b/src/lmathlib.c
@@ -15,7 +15,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "lrotable.h"
 
 #undef PI
 #define PI (3.14159265358979323846)
@@ -213,19 +213,22 @@ static int math_randomseed (lua_State *L) {
 }
 
 
-static const luaL_Reg mathlib[] = {
+const luaL_reg mathlib[] = {
   {"abs",   math_abs},
   {"acos",  math_acos},
   {"asin",  math_asin},
   {"atan2", math_atan2},
   {"atan",  math_atan},
   {"ceil",  math_ceil},
-  {"cosh",   math_cosh},
+  {"cosh",  math_cosh},
   {"cos",   math_cos},
   {"deg",   math_deg},
   {"exp",   math_exp},
   {"floor", math_floor},
-  {"fmod",   math_fmod},
+  {"fmod",  math_fmod},
+#if LUA_OPTIMIZE_MEMORY > 0 && defined(LUA_COMPAT_MOD)
+  {"mod",   math_fmod}, 
+#endif
   {"frexp", math_frexp},
   {"ldexp", math_ldexp},
   {"log10", math_log10},
@@ -245,11 +248,19 @@ static const luaL_Reg mathlib[] = {
   {NULL, NULL}
 };
 
+const luaR_value_entry mathlib_vals[] = {
+  {"pi",   PI},
+  {"huge", HUGE_VAL},
+  {NULL, 0}
+};
 
 /*
 ** Open math library
 */
 LUALIB_API int luaopen_math (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY > 0
+  return 0;
+#else
   luaL_register(L, LUA_MATHLIBNAME, mathlib);
   lua_pushnumber(L, PI);
   lua_setfield(L, -2, "pi");
@@ -260,5 +271,6 @@ LUALIB_API int luaopen_math (lua_State *L) {
   lua_setfield(L, -2, "mod");
 #endif
   return 1;
+#endif
 }
 
diff --git a/src/loadlib.c b/src/loadlib.c
index 6158c53..02e4d44 100644
--- a/src/loadlib.c
+++ b/src/loadlib.c
@@ -20,7 +20,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "lrotable.h"
 
 /* prefix for open functions in C libraries */
 #define LUA_POF		"luaopen_"
@@ -459,6 +459,14 @@ static int ll_require (lua_State *L) {
       luaL_error(L, "loop or previous error loading module " LUA_QS, name);
     return 1;  /* package is already loaded */
   }
+  // Is this a readonly table?
+  lu_byte keytype;
+  luaR_result res = luaR_findglobal(name, &keytype);
+  if (keytype == LUA_TROTABLE) {
+    lua_pushrotable(L, (void*)(size_t)res);
+    return 1;
+  }
+  
   /* else must load it; iterate over available loaders */
   lua_getfield(L, LUA_ENVIRONINDEX, "loaders");
   if (!lua_istable(L, -1))
@@ -628,10 +636,10 @@ LUALIB_API int luaopen_package (lua_State *L) {
   int i;
   /* create new type _LOADLIB */
   luaL_newmetatable(L, "_LOADLIB");
-  lua_pushcfunction(L, gctm);
+  lua_pushlightfunction(L, gctm);
   lua_setfield(L, -2, "__gc");
   /* create `package' table */
-  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);
+  luaL_register_light(L, LUA_LOADLIBNAME, pk_funcs);
 #if defined(LUA_COMPAT_LOADLIB) 
   lua_getfield(L, -1, "loadlib");
   lua_setfield(L, LUA_GLOBALSINDEX, "loadlib");
diff --git a/src/lobject.c b/src/lobject.c
index be53550..5ace1c4 100644
--- a/src/lobject.c
+++ b/src/lobject.c
@@ -79,6 +79,8 @@ int luaO_rawequalObj (const TValue *t1, const TValue *t2) {
     case LUA_TBOOLEAN:
       return bvalue(t1) == bvalue(t2);  /* boolean true must be 1 !! */
     case LUA_TLIGHTUSERDATA:
+    case LUA_TROTABLE:
+    case LUA_TLIGHTFUNCTION:
       return pvalue(t1) == pvalue(t2);
     default:
       lua_assert(iscollectable(t1));
diff --git a/src/lobject.h b/src/lobject.h
index 574e1bb..69e7509 100644
--- a/src/lobject.h
+++ b/src/lobject.h
@@ -85,11 +85,15 @@ typedef struct lua_TValue {
 #define ttisuserdata(o)	(ttype(o) == LUA_TUSERDATA)
 #define ttisthread(o)	(ttype(o) == LUA_TTHREAD)
 #define ttislightuserdata(o)	(ttype(o) == LUA_TLIGHTUSERDATA)
+#define ttisrotable(o) (ttype(o) == LUA_TROTABLE)
+#define ttislightfunction(o)  (ttype(o) == LUA_TLIGHTFUNCTION)
 
 /* Macros to access values */
 #define ttype(o)	((o)->tt)
 #define gcvalue(o)	check_exp(iscollectable(o), (o)->value.gc)
 #define pvalue(o)	check_exp(ttislightuserdata(o), (o)->value.p)
+#define rvalue(o)	check_exp(ttisrotable(o), (o)->value.p)
+#define fvalue(o) check_exp(ttislightfunction(o), (o)->value.p)
 #define nvalue(o)	check_exp(ttisnumber(o), (o)->value.n)
 #define rawtsvalue(o)	check_exp(ttisstring(o), &(o)->value.gc->ts)
 #define tsvalue(o)	(&rawtsvalue(o)->tsv)
@@ -117,42 +121,54 @@ typedef struct lua_TValue {
 #define setnilvalue(obj) ((obj)->tt=LUA_TNIL)
 
 #define setnvalue(obj,x) \
-  { TValue *i_o=(obj); i_o->value.n=(x); i_o->tt=LUA_TNUMBER; }
+  { lua_Number i_x = (x); TValue *i_o=(obj); i_o->value.n=i_x; i_o->tt=LUA_TNUMBER; }
 
 #define setpvalue(obj,x) \
-  { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTUSERDATA; }
+  { void *i_x = (x); TValue *i_o=(obj); i_o->value.p=i_x; i_o->tt=LUA_TLIGHTUSERDATA; }
+
+#define setrvalue(obj,x) \
+  { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TROTABLE; }
+  
+#define setfvalue(obj,x) \
+  { TValue *i_o=(obj); i_o->value.p=(x); i_o->tt=LUA_TLIGHTFUNCTION; }
 
 #define setbvalue(obj,x) \
-  { TValue *i_o=(obj); i_o->value.b=(x); i_o->tt=LUA_TBOOLEAN; }
+  { int i_x = (x); TValue *i_o=(obj); i_o->value.b=i_x; i_o->tt=LUA_TBOOLEAN; }
 
 #define setsvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TSTRING; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TSTRING; \
     checkliveness(G(L),i_o); }
 
 #define setuvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TUSERDATA; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TUSERDATA; \
     checkliveness(G(L),i_o); }
 
 #define setthvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTHREAD; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TTHREAD; \
     checkliveness(G(L),i_o); }
 
 #define setclvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TFUNCTION; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TFUNCTION; \
     checkliveness(G(L),i_o); }
 
 #define sethvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TTABLE; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TTABLE; \
     checkliveness(G(L),i_o); }
 
 #define setptvalue(L,obj,x) \
-  { TValue *i_o=(obj); \
-    i_o->value.gc=cast(GCObject *, (x)); i_o->tt=LUA_TPROTO; \
+  { GCObject *i_x = cast(GCObject *, (x)); \
+    TValue *i_o=(obj); \
+    i_o->value.gc=i_x; i_o->tt=LUA_TPROTO; \
     checkliveness(G(L),i_o); }
 
 
@@ -223,24 +239,29 @@ typedef union Udata {
 } Udata;
 
 
-
-
 /*
 ** Function Prototypes
 */
+
 typedef struct Proto {
   CommonHeader;
   TValue *k;  /* constants used by the function */
   Instruction *code;
   struct Proto **p;  /* functions defined inside the function */
+#ifdef LUA_OPTIMIZE_DEBUG
+  unsigned char *packedlineinfo;
+#else
   int *lineinfo;  /* map from opcodes to source lines */
+#endif
   struct LocVar *locvars;  /* information about local variables */
   TString **upvalues;  /* upvalue names */
   TString  *source;
   int sizeupvalues;
   int sizek;  /* size of `k' */
   int sizecode;
+#ifndef LUA_OPTIMIZE_DEBUG
   int sizelineinfo;
+#endif
   int sizep;  /* size of `p' */
   int sizelocvars;
   int linedefined;
@@ -312,7 +333,7 @@ typedef union Closure {
 } Closure;
 
 
-#define iscfunction(o)	(ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)
+#define iscfunction(o)	((ttype(o) == LUA_TFUNCTION && clvalue(o)->c.isC)||(ttype(o)==LUA_TLIGHTFUNCTION))
 #define isLfunction(o)	(ttype(o) == LUA_TFUNCTION && !clvalue(o)->c.isC)
 
 
@@ -353,7 +374,8 @@ typedef struct Table {
 ** `module' operation for hashing (size is always a power of 2)
 */
 #define lmod(s,size) \
-	(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
+  (cast(int, (s) % (size)))
+	//(check_exp((size&(size-1))==0, (cast(int, (s) & ((size)-1)))))
 
 
 #define twoto(x)	(1<<(x))
diff --git a/src/loslib.c b/src/loslib.c
index 8bca646..d0800eb 100644
--- a/src/loslib.c
+++ b/src/loslib.c
@@ -218,7 +218,7 @@ static int os_exit (lua_State *L) {
   exit(luaL_optint(L, 1, EXIT_SUCCESS));
 }
 
-static const luaL_Reg syslib[] = {
+const luaL_Reg syslib[] = {
   {"clock",     os_clock},
   {"date",      os_date},
   {"difftime",  os_difftime},
@@ -240,7 +240,11 @@ static const luaL_Reg syslib[] = {
 
 
 LUALIB_API int luaopen_os (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY > 0
+  return 0;
+#else
   luaL_register(L, LUA_OSLIBNAME, syslib);
   return 1;
+#endif
 }
 
diff --git a/src/lparser.c b/src/lparser.c
index dda7488..d3b8015 100644
--- a/src/lparser.c
+++ b/src/lparser.c
@@ -6,6 +6,7 @@
 
 
 #include <string.h>
+#include <stdio.h>   /*DEBUG*/
 
 #define lparser_c
 #define LUA_CORE
@@ -25,8 +26,6 @@
 #include "lstring.h"
 #include "ltable.h"
 
-
-
 #define hasmultret(k)		((k) == VCALL || (k) == VVARARG)
 
 #define getlocvar(fs, i)	((fs)->f->locvars[(fs)->actvar[i]])
@@ -344,6 +343,12 @@ static void open_func (LexState *ls, FuncState *fs) {
   fs->bl = NULL;
   f->source = ls->source;
   f->maxstacksize = 2;  /* registers 0/1 are always valid */
+#ifdef LUA_OPTIMIZE_DEBUG
+  fs->packedlineinfoSize = 0;
+  fs->lastline = 0;
+  fs->lastlineOffset = 0;
+  fs->lineinfoLastPC = -1;
+#endif
   fs->h = luaH_new(L, 0, 0);
   /* anchor table of constants and prototype (to avoid being collected) */
   sethvalue2s(L, L->top, fs->h);
@@ -361,8 +366,14 @@ static void close_func (LexState *ls) {
   luaK_ret(fs, 0, 0);  /* final return */
   luaM_reallocvector(L, f->code, f->sizecode, fs->pc, Instruction);
   f->sizecode = fs->pc;
+#ifdef LUA_OPTIMIZE_DEBUG
+  f->packedlineinfo[fs->lastlineOffset+1]=0;
+  luaM_reallocvector(L, f->packedlineinfo, fs->packedlineinfoSize, 
+                     fs->lastlineOffset+2, unsigned char);
+#else
   luaM_reallocvector(L, f->lineinfo, f->sizelineinfo, fs->pc, int);
   f->sizelineinfo = fs->pc;
+#endif
   luaM_reallocvector(L, f->k, f->sizek, fs->nk, TValue);
   f->sizek = fs->nk;
   luaM_reallocvector(L, f->p, f->sizep, fs->np, Proto *);
@@ -379,18 +390,39 @@ static void close_func (LexState *ls) {
   L->top -= 2;  /* remove table and prototype from the stack */
 }
 
+#ifdef LUA_OPTIMIZE_DEBUG
+static void compile_stripdebug(lua_State *L, Proto *f) { 
+  int level;
+  lua_pushlightuserdata(L, &luaG_stripdebug );
+  lua_gettable(L, LUA_REGISTRYINDEX);
+  level = lua_isnil(L, -1) ? LUA_OPTIMIZE_DEBUG : lua_tointeger(L, -1);
+  lua_pop(L, 1);
+  
+  if (level > 1) { 
+    int len = luaG_stripdebug(L, f, level, 1);
+    UNUSED(len);
+  }
+}
+#endif
 
 Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
   struct LexState lexstate;
   struct FuncState funcstate;
+  TString *tname = luaS_new(L, name);
+  setsvalue2s(L, L->top, tname);  /* protect name */
+  incr_top(L);
   lexstate.buff = buff;
-  luaX_setinput(L, &lexstate, z, luaS_new(L, name));
+  luaX_setinput(L, &lexstate, z, tname);
   open_func(&lexstate, &funcstate);
   funcstate.f->is_vararg = VARARG_ISVARARG;  /* main func. is always vararg */
   luaX_next(&lexstate);  /* read first token */
   chunk(&lexstate);
   check(&lexstate, TK_EOS);
   close_func(&lexstate);
+#ifdef LUA_OPTIMIZE_DEBUG
+  compile_stripdebug(L, funcstate.f);
+#endif
+  L->top--; /* remove 'name' from stack */
   lua_assert(funcstate.prev == NULL);
   lua_assert(funcstate.f->nups == 0);
   lua_assert(lexstate.fs == NULL);
@@ -398,7 +430,6 @@ Proto *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, const char *name) {
 }
 
 
-
 /*============================================================*/
 /* GRAMMAR RULES */
 /*============================================================*/
diff --git a/src/lparser.h b/src/lparser.h
index 18836af..74b7aa6 100644
--- a/src/lparser.h
+++ b/src/lparser.h
@@ -72,6 +72,12 @@ typedef struct FuncState {
   lu_byte nactvar;  /* number of active local variables */
   upvaldesc upvalues[LUAI_MAXUPVALUES];  /* upvalues */
   unsigned short actvar[LUAI_MAXVARS];  /* declared-variable stack */
+#ifdef LUA_OPTIMIZE_DEBUG
+  int packedlineinfoSize; /* only used during compilation for line info */
+  int lastline;           /* ditto */
+  int lastlineOffset;     /* ditto */
+  int lineinfoLastPC;     /* ditto */
+#endif
 } FuncState;
 
 
diff --git a/src/lstate.c b/src/lstate.c
index 9c69517..34f823a 100644
--- a/src/lstate.c
+++ b/src/lstate.c
@@ -38,8 +38,8 @@ typedef struct LG {
 } LG;
   
 /* forward declarations for lock creation/deletion */
-void * _lua_newlock();
-void _lua_freelock(void *);
+//void * _lua_newlock();
+//void _lua_freelock(void *);
 
 static void stack_init (lua_State *L1, lua_State *L) {
   /* initialize CallInfo array */
@@ -117,7 +117,7 @@ static void close_state (lua_State *L) {
   freestack(L, L);
   lua_assert(g->totalbytes == sizeof(LG));
   if (g->lockstate) lua_unlock(L);
-  _lua_freelock(g->lock);
+  //_lua_freelock(g->lock);
   (*g->frealloc)(g->ud, fromstate(L), state_size(LG), 0);
 }
 
@@ -125,6 +125,8 @@ static void close_state (lua_State *L) {
 lua_State *luaE_newthread (lua_State *L) {
   lua_State *L1 = tostate(luaM_malloc(L, state_size(lua_State)));
   luaC_link(L, obj2gco(L1), LUA_TTHREAD);
+  setthvalue(L, L->top, L1); /* put thread on stack */
+  incr_top(L);
   preinit_state(L1, G(L));
   stack_init(L1, L);  /* init stack */
   setobj2n(L, gt(L1), gt(L));  /* share table of globals */
@@ -132,7 +134,8 @@ lua_State *luaE_newthread (lua_State *L) {
   L1->basehookcount = L->basehookcount;
   L1->hook = L->hook;
   resethookcount(L1);
-  lua_assert(iswhite(obj2gco(L1)));
+  lua_assert(!isdead(G(L), obj2gco(L1)));
+  L->top--; /* remove thread from stack */
   return L1;
 }
 
@@ -166,6 +169,7 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   g->uvhead.u.l.prev = &g->uvhead;
   g->uvhead.u.l.next = &g->uvhead;
   g->GCthreshold = 0;  /* mark it as unfinished state */
+  g->estimate = 0;
   g->strt.size = 0;
   g->strt.nuse = 0;
   g->strt.hash = NULL;
@@ -173,6 +177,7 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   luaZ_initbuffer(L, &g->buff);
   g->panic = NULL;
   g->gcstate = GCSpause;
+  g->gcflags = GCFlagsNone;
   g->rootgc = obj2gco(L);
   g->sweepstrgc = 0;
   g->sweepgc = &g->rootgc;
@@ -181,10 +186,11 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   g->weak = NULL;
   g->tmudata = NULL;
   g->totalbytes = sizeof(LG);
+  g->memlimit = 0;
   g->gcpause = LUAI_GCPAUSE;
   g->gcstepmul = LUAI_GCMUL;
   g->gcdept = 0;
-  g->lock = _lua_newlock();
+  //g->lock = _lua_newlock();
   g->lockstate = 0;
   g->haltstate = 0;
   for (i=0; i<NUM_TAGS; i++) g->mt[i] = NULL;
diff --git a/src/lstate.h b/src/lstate.h
index 7f9e91b..2f245f3 100644
--- a/src/lstate.h
+++ b/src/lstate.h
@@ -62,9 +62,9 @@ typedef struct CallInfo {
 
 
 
-#define curr_func(L)	(clvalue(L->ci->func))
-#define ci_func(ci)	(clvalue((ci)->func))
-#define f_isLua(ci)	(!ci_func(ci)->c.isC)
+#define curr_func(L)	(ttisfunction(L->ci->func) ? clvalue(L->ci->func) : NULL)
+#define ci_func(ci)	(ttisfunction((ci)->func) ? clvalue((ci)->func) : NULL)
+#define f_isLua(ci)	(!ttislightfunction((ci)->func) && !ci_func(ci)->c.isC)
 #define isLua(ci)	(ttisfunction((ci)->func) && f_isLua(ci))
 
 
@@ -77,6 +77,7 @@ typedef struct global_State {
   void *ud;         /* auxiliary data to `frealloc' */
   lu_byte currentwhite;
   lu_byte gcstate;  /* state of garbage collector */
+  lu_byte gcflags;  /* flags for the garbage collector */
   int sweepstrgc;  /* position of sweep in `strt' */
   GCObject *rootgc;  /* list of all collectable objects */
   GCObject **sweepgc;  /* position of sweep in `rootgc' */
@@ -87,6 +88,7 @@ typedef struct global_State {
   Mbuffer buff;  /* temporary buffer for string concatentation */
   lu_mem GCthreshold;
   lu_mem totalbytes;  /* number of bytes currently allocated */
+  lu_mem memlimit;  /* maximum number of bytes that can be allocated, 0 = no limit. */
   lu_mem estimate;  /* an estimate of number of bytes actually in use */
   lu_mem gcdept;  /* how much GC is `behind schedule' */
   int gcpause;  /* size of pause between successive GCs */
diff --git a/src/lstring.c b/src/lstring.c
index 4526530..5d681b1 100644
--- a/src/lstring.c
+++ b/src/lstring.c
@@ -20,30 +20,34 @@
 
 
 void luaS_resize (lua_State *L, int newsize) {
-  GCObject **newhash;
   stringtable *tb;
   int i;
-  if (G(L)->gcstate == GCSsweepstring)
-    return;  /* cannot resize during GC traverse */
-  newhash = luaM_newvector(L, newsize, GCObject *);
   tb = &G(L)->strt;
-  for (i=0; i<newsize; i++) newhash[i] = NULL;
+  if (luaC_sweepstrgc(L) || newsize == tb->size || is_resizing_strings_gc(L))
+    return;  /* cannot resize during GC traverse or doesn't need to be resized */
+  set_resizing_strings_gc(L);
+  if (newsize > tb->size) {
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
+    for (i=tb->size; i<newsize; i++) tb->hash[i] = NULL;
+  }
   /* rehash */
   for (i=0; i<tb->size; i++) {
     GCObject *p = tb->hash[i];
-    while (p > (GCObject*)256) {  /* for each node in the list */
+    tb->hash[i] = NULL;
+    while (p) {  /* for each node in the list */
       GCObject *next = p->gch.next;  /* save next */
       unsigned int h = gco2ts(p)->hash;
       int h1 = lmod(h, newsize);  /* new position */
       lua_assert(cast_int(h%newsize) == lmod(h, newsize));
-      p->gch.next = newhash[h1];  /* chain it */
-      newhash[h1] = p;
+      p->gch.next = tb->hash[h1];  /* chain it */
+      tb->hash[h1] = p;
       p = next;
     }
   }
-  luaM_freearray(L, tb->hash, tb->size, TString *);
+  if (newsize < tb->size)
+    luaM_reallocvector(L, tb->hash, tb->size, newsize, GCObject *);
   tb->size = newsize;
-  tb->hash = newhash;
+  unset_resizing_strings_gc(L);
 }
 
 
@@ -53,6 +57,9 @@ static TString *newlstr (lua_State *L, const char *str, size_t l,
   stringtable *tb;
   if (l+1 > (MAX_SIZET - sizeof(TString))/sizeof(char))
     luaM_toobig(L);
+  tb = &G(L)->strt;
+  if ((tb->nuse + 1) > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
+    luaS_resize(L, tb->size*2);  /* too crowded */
   ts = cast(TString *, luaM_malloc(L, (l+1)*sizeof(char)+sizeof(TString)));
   ts->tsv.len = l;
   ts->tsv.hash = h;
@@ -61,13 +68,10 @@ static TString *newlstr (lua_State *L, const char *str, size_t l,
   ts->tsv.reserved = 0;
   memcpy(ts+1, str, l*sizeof(char));
   ((char *)(ts+1))[l] = '\0';  /* ending 0 */
-  tb = &G(L)->strt;
   h = lmod(h, tb->size);
   ts->tsv.next = tb->hash[h];  /* chain new entry */
   tb->hash[h] = obj2gco(ts);
   tb->nuse++;
-  if (tb->nuse > cast(lu_int32, tb->size) && tb->size <= MAX_INT/2)
-    luaS_resize(L, tb->size*2);  /* too crowded */
   return ts;
 }
 
diff --git a/src/lstrlib.c b/src/lstrlib.c
index d3e8e82..03642fb 100644
--- a/src/lstrlib.c
+++ b/src/lstrlib.c
@@ -18,7 +18,7 @@
 
 #include "lauxlib.h"
 #include "lualib.h"
-
+#include "lrotable.h"
 
 /* macro to `unsign' a character */
 #define uchar(c)        ((unsigned char)(c))
@@ -27,7 +27,7 @@
 ** Some sizes are better limited to fit in 'int', but must also fit in
 ** 'size_t'. (We assume that 'lua_Integer' cannot be smaller than 'int'.)
 */
-#define MAX_SIZET       ((size_t)(~(size_t)0))
+//#define MAX_SIZET       ((size_t)(~(size_t)0))
 
 #define MAXSIZE  \
         (sizeof(size_t) < sizeof(int) ? MAX_SIZET : (size_t)(INT_MAX))
@@ -639,7 +639,8 @@ static void add_value (struct string_gsub_state * st, const char *s) {
       add_s(&st->ms, &st->b, s, st->e);
       return;
     }
-    case LUA_TFUNCTION: {
+    case LUA_TFUNCTION:
+    case LUA_TLIGHTFUNCTION: {
       int n;
       lua_pushvalue(L, 3);
       n = push_captures(&st->ms, s, st->e);
@@ -683,7 +684,8 @@ static int str_gsub (lua_State *L) {
   s->res = 0;
   s->max_s = luaL_optint(L, 4, srcl + 1);
   luaL_argcheck(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||
-                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,
+                   tr == LUA_TFUNCTION || tr == LUA_TTABLE ||
+                   tr == LUA_TLIGHTFUNCTION, 3,
                       "string/function/table expected");
   luaL_buffinit(L, &s->b);
   s->ms.L = L;
@@ -1311,30 +1313,55 @@ static int str_unpack(lua_State *L) {
 /* }====================================================== */
 
 
+/* Compile the correct version of "gfind" */
+#if LUA_OPTIMIZE_MEMORY > 0 && defined(LUA_COMPAT_GFIND)
+#define LUA_GFIND_DECL	{"gfind", gmatch}
+#else
+#define LUA_GFIND_DECL  {"gfind", gfind_nodef}
+#endif
+
+#define LUA_STRLIB_FUNCLIST\
+  {"byte", str_byte},\
+  {"char", str_char},\
+  {"dump", str_dump},\
+  {"find", str_find},\
+  {"format", str_format},\
+  LUA_GFIND_DECL,\
+  {"gmatch", gmatch},\
+  {"gsub", str_gsub},\
+  {"len", str_len},\
+  {"lower", str_lower},\
+  {"match", str_match},\
+  {"rep", str_rep},\
+  {"reverse", str_reverse},\
+  {"sub", str_sub},\
+  {"upper", str_upper}
+
+#if LUA_OPTIMIZE_MEMORY == 0
+static const luaL_Reg strlib[] = {
+  LUA_STRLIB_FUNCLIST,
+  {NULL, NULL}
+};
+#else
+static const luaL_Reg strlib_funcs[] = {
+  LUA_STRLIB_FUNCLIST,
+  {NULL, NULL}
+};
+
+static int str_index(lua_State *L)
+{
+  return luaR_findfunction(L, strlib_funcs);
+}
+
 static const luaL_Reg strlib[] = {
-  {"byte", str_byte},
-  {"char", str_char},
-  {"dump", str_dump},
-  {"find", str_find},
-  {"format", str_format},
-  {"gfind", gfind_nodef},
-  {"gmatch", gmatch},
-  {"gsub", str_gsub},
-  {"len", str_len},
-  {"lower", str_lower},
-  {"match", str_match},
-  {"pack", str_pack},
-  {"packsize", str_packsize},
-  {"rep", str_rep},
-  {"reverse", str_reverse},
-  {"sub", str_sub},
-  {"unpack", str_unpack},
-  {"upper", str_upper},
+  {"__index", str_index},
   {NULL, NULL}
 };
+#endif
 
 
 static void createmetatable (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY == 0
   lua_createtable(L, 0, 1);  /* create metatable for strings */
   lua_pushliteral(L, "");  /* dummy string */
   lua_pushvalue(L, -2);
@@ -1343,6 +1370,12 @@ static void createmetatable (lua_State *L) {
   lua_pushvalue(L, -2);  /* string library... */
   lua_setfield(L, -2, "__index");  /* ...is the __index metamethod */
   lua_pop(L, 1);  /* pop metatable */
+#else
+  lua_pushliteral(L,"");
+  lua_pushvalue(L, -2);
+  lua_setmetatable(L, -2);
+  lua_pop(L, 1);
+#endif
 }
 
 
@@ -1351,11 +1384,13 @@ static void createmetatable (lua_State *L) {
 */
 LUALIB_API int luaopen_string (lua_State *L) {
   luaL_register(L, LUA_STRLIBNAME, strlib);
-#if defined(LUA_COMPAT_GFIND)
+#if LUA_OPTIMIZE_MEMORY > 0
+  lua_pushvalue(L, -1);
+  lua_setmetatable(L, -2);
+#elif defined(LUA_COMPAT_GFIND)
   lua_getfield(L, -1, "gmatch");
   lua_setfield(L, -2, "gfind");
 #endif
   createmetatable(L);
-  return 1;
+  return 1;  
 }
-
diff --git a/src/ltable.c b/src/ltable.c
index fced7eb..228c342 100644
--- a/src/ltable.c
+++ b/src/ltable.c
@@ -106,6 +106,8 @@ static Node *mainposition (const Table *t, const TValue *key) {
     case LUA_TBOOLEAN:
       return hashboolean(t, bvalue(key));
     case LUA_TLIGHTUSERDATA:
+    case LUA_TROTABLE:
+    case LUA_TLIGHTFUNCTION:
       return hashpointer(t, pvalue(key));
     default:
       return hashpointer(t, gcvalue(key));
@@ -269,20 +271,35 @@ static void setarrayvector (lua_State *L, Table *t, int size) {
 }
 
 
-static void setnodevector (lua_State *L, Table *t, int size) {
+static Node *getfreepos (Table *t) {
+  while (t->lastfree-- > t->node) {
+    if (ttisnil(gkey(t->lastfree)))
+      return t->lastfree;
+  }
+  return NULL;  /* could not find a free place */
+}
+
+
+static void resizenodevector (lua_State *L, Table *t, int oldsize, int newsize) {
   int lsize;
-  if (size == 0) {  /* no elements to hash part? */
+  if (newsize == 0) {  /* no elements to hash part? */
     t->node = cast(Node *, dummynode);  /* use common `dummynode' */
     lsize = 0;
   }
   else {
+    Node *node = t->node;
     int i;
-    lsize = ceillog2(size);
+    lsize = ceillog2(newsize);
     if (lsize > MAXBITS)
       luaG_runerror(L, "table overflow");
-    size = twoto(lsize);
-    t->node = luaM_newvector(L, size, Node);
-    for (i=0; i<size; i++) {
+    newsize = twoto(lsize);
+    if (node == dummynode) {
+      oldsize = 0;
+      node = NULL; /* don't try to realloc `dummynode' pointer. */
+    }
+    luaM_reallocvector(L, node, oldsize, newsize, Node);
+    t->node = node;
+    for (i=oldsize; i<newsize; i++) {
       Node *n = gnode(t, i);
       gnext(n) = NULL;
       setnilvalue(gkey(n));
@@ -290,19 +307,138 @@ static void setnodevector (lua_State *L, Table *t, int size) {
     }
   }
   t->lsizenode = cast_byte(lsize);
-  t->lastfree = gnode(t, size);  /* all positions are free */
+  t->lastfree = gnode(t, newsize);  /* reset lastfree to end of table. */
+}
+
+
+static Node *find_prev_node(Node *mp, Node *next) {
+  Node *prev = mp;
+  while (prev != NULL && gnext(prev) != next) prev = gnext(prev);
+  return prev;
+}
+
+
+/*
+** move a node from it's old position to it's new position during a rehash;
+** first, check whether the moving node's main position is free. If not, check whether
+** colliding node is in its main position or not: if it is not, move colliding
+** node to an empty place and put moving node in its main position; otherwise
+** (colliding node is in its main position), moving node goes to an empty position. 
+*/
+static int move_node (lua_State *L, Table *t, Node *node) {
+  Node *mp = mainposition(t, key2tval(node));
+  /* if node is in it's main position, don't need to move node. */
+  if (mp == node) return 1;
+  /* if node is in it's main position's chain, don't need to move node. */
+  if (find_prev_node(mp, node) != NULL) return 1;
+  /* is main position is free? */
+  if (!ttisnil(gval(mp)) || mp == dummynode) {
+    /* no; move main position node if it is out of its main position */
+    Node *othermp;
+    othermp = mainposition(t, key2tval(mp));
+    if (othermp != mp) {  /* is colliding node out of its main position? */
+      /* yes; swap colliding node with the node that is being moved. */
+      Node *prev;
+      Node tmp;
+      tmp = *node;
+      prev = find_prev_node(othermp, mp);  /* find previous */
+      if (prev != NULL) gnext(prev) = node;  /* redo the chain with `n' in place of `mp' */
+      *node = *mp;  /* copy colliding node into free pos. (mp->next also goes) */
+      *mp = tmp;
+      return (prev != NULL) ? 1 : 0; /* is colliding node part of its main position chain? */
+    }
+    else {  /* colliding node is in its own main position */
+      /* add node to main position's chain. */
+      gnext(node) = gnext(mp);  /* chain new position */
+      gnext(mp) = node;
+    }
+  }
+  else { /* main position is free, move node */
+    *mp = *node;
+    gnext(node) = NULL;
+    setnilvalue(gkey(node));
+    setnilvalue(gval(node));
+  }
+  return 1;
+}
+
+
+static int move_number (lua_State *L, Table *t, Node *node) {
+  int key;
+  lua_Number n = nvalue(key2tval(node));
+  lua_number2int(key, n);
+  if (luai_numeq(cast_num(key), nvalue(key2tval(node)))) {/* index is int? */
+    /* (1 <= key && key <= t->sizearray) */
+    if (cast(unsigned int, key-1) < cast(unsigned int, t->sizearray)) {
+      setobjt2t(L, &t->array[key-1], gval(node));
+      setnilvalue(gkey(node));
+      setnilvalue(gval(node));
+      return 1;
+    }
+  }
+  return 0;
+}
+
+
+static void resize_hashpart (lua_State *L, Table *t, int nhsize) {
+  int i;
+  int lsize=0;
+  int oldhsize = (t->node != dummynode) ? twoto(t->lsizenode) : 0;
+  if (nhsize > 0) { /* round new hashpart size up to next power of two. */
+    lsize=ceillog2(nhsize);
+    if (lsize > MAXBITS)
+      luaG_runerror(L, "table overflow");
+  }
+  nhsize = twoto(lsize);
+  /* grow hash part to new size. */
+  if (oldhsize < nhsize)
+    resizenodevector(L, t, oldhsize, nhsize);
+  else { /* hash part might be shrinking */
+    if (nhsize > 0) {
+      t->lsizenode = cast_byte(lsize);
+      t->lastfree = gnode(t, nhsize);  /* reset lastfree back to end of table. */
+    }
+    else { /* new hashpart size is zero. */
+      resizenodevector(L, t, oldhsize, nhsize);
+      return;
+    }
+  }
+  /* break old chains, try moving int keys to array part and compact keys into new hashpart */
+  for (i = 0; i < oldhsize; i++) {
+    Node *old = gnode(t, i);
+    gnext(old) = NULL;
+    if (ttisnil(gval(old))) { /* clear nodes with nil values. */
+      setnilvalue(gkey(old));
+      continue;
+    }
+    if (ttisnumber(key2tval(old))) { /* try moving the int keys into array part. */
+      if(move_number(L, t, old))
+        continue;
+    }
+    if (i >= nhsize) { /* move all valid keys to indices < nhsize. */
+      Node *n = getfreepos(t);  /* get a free place */
+      lua_assert(n != dummynode && n != NULL);
+      *n = *old;
+    }
+  }
+  /* shrink hash part */
+  if (oldhsize > nhsize)
+    resizenodevector(L, t, oldhsize, nhsize);
+  /* move nodes to their new mainposition and re-create node chains */
+  for (i = 0; i < nhsize; i++) {
+    Node *curr = gnode(t, i);
+    if (!ttisnil(gval(curr)))
+      while (move_node(L, t, curr) == 0);
+  }
 }
 
 
 static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
   int i;
   int oldasize = t->sizearray;
-  int oldhsize = t->lsizenode;
-  Node *nold = t->node;  /* save old hash ... */
   if (nasize > oldasize)  /* array part must grow? */
     setarrayvector(L, t, nasize);
-  /* create new hash part with appropriate size */
-  setnodevector(L, t, nhsize);  
+  resize_hashpart(L, t, nhsize);
   if (nasize < oldasize) {  /* array part must shrink? */
     t->sizearray = nasize;
     /* re-insert elements from vanishing slice */
@@ -313,14 +449,6 @@ static void resize (lua_State *L, Table *t, int nasize, int nhsize) {
     /* shrink array */
     luaM_reallocvector(L, t->array, oldasize, nasize, TValue);
   }
-  /* re-insert elements from hash part */
-  for (i = twoto(oldhsize) - 1; i >= 0; i--) {
-    Node *old = nold+i;
-    if (!ttisnil(gval(old)))
-      setobjt2t(L, luaH_set(L, t, key2tval(old)), gval(old));
-  }
-  if (nold != dummynode)
-    luaM_freearray(L, nold, twoto(oldhsize), Node);  /* free old array */
 }
 
 
@@ -358,6 +486,8 @@ static void rehash (lua_State *L, Table *t, const TValue *ek) {
 Table *luaH_new (lua_State *L, int narray, int nhash) {
   Table *t = luaM_new(L, Table);
   luaC_link(L, obj2gco(t), LUA_TTABLE);
+  sethvalue2s(L, L->top, t); /* put table on stack */
+  incr_top(L);
   t->metatable = NULL;
   t->flags = cast_byte(~0);
   /* temporary values (kept only if some malloc fails) */
@@ -366,7 +496,8 @@ Table *luaH_new (lua_State *L, int narray, int nhash) {
   t->lsizenode = 0;
   t->node = cast(Node *, dummynode);
   setarrayvector(L, t, narray);
-  setnodevector(L, t, nhash);
+  resizenodevector(L, t, 0, nhash);
+  L->top--; /* remove table from stack */
   return t;
 }
 
@@ -379,15 +510,6 @@ void luaH_free (lua_State *L, Table *t) {
 }
 
 
-static Node *getfreepos (Table *t) {
-  while (t->lastfree-- > t->node) {
-    if (ttisnil(gkey(t->lastfree)))
-      return t->lastfree;
-  }
-  return NULL;  /* could not find a free place */
-}
-
-
 
 /*
 ** inserts a new key into a hash table; first, check whether key's main 
diff --git a/src/ltablib.c b/src/ltablib.c
index a0de881..49247d6 100644
--- a/src/ltablib.c
+++ b/src/ltablib.c
@@ -6,6 +6,7 @@
 
 
 #include <stddef.h>
+#include <string.h>
 
 #define ltablib_c
 #define LUA_LIB
@@ -28,7 +29,7 @@ static int foreachi (lua_State *L) {
     goto resume;
   }
   n = aux_igetn(L, 1, -1);
-  luaL_checktype(L, 2, LUA_TFUNCTION);
+  luaL_checkanyfunction(L, 2);
   lua_settop(L, 2);
   lua_pushinteger(L, n);  /* cache n because aux_igetn may be expensive */
    for (i=1; i <= n; i++) {
@@ -48,7 +49,7 @@ resume:
 static int foreach (lua_State *L) {
   if (lua_vcontext(L)) goto resume;
   luaL_checktype(L, 1, LUA_TTABLE);
-  luaL_checktype(L, 2, LUA_TFUNCTION);
+  luaL_checkanyfunction(L, 2);
   lua_pushnil(L);  /* first key */
   while (lua_next(L, 1)) {
     lua_pushvalue(L, 2);  /* function */
@@ -201,6 +202,26 @@ struct table_sort_state {
     struct table_sort_args * args;
 };
 
+static int l_strcmp (lua_State *L, int ls, int rs) {
+  size_t ll, lr;
+  const char *l = lua_tolstring(L, ls, &ll);
+  const char *r = lua_tolstring(L, rs, &lr);
+  for (;;) {
+    int temp = strcoll(l, r);
+    if (temp != 0) return temp;
+    else {  /* strings are equal up to a `\0' */
+      size_t len = strlen(l);  /* index of first `\0' in both strings */
+      if (len == lr)  /* r is finished? */
+        return (len == ll) ? 0 : 1;
+      else if (len == ll)  /* l is finished? */
+        return -1;  /* l is smaller than r (because r is not finished) */
+      /* both strings longer than `len'; go on comparing (after the `\0') */
+      len++;
+      l += len; ll -= len; r += len; lr -= len;
+    }
+  }
+}
+
 static int sort_comp (lua_State *L, int a, int b, struct table_sort_state * s, int ss) {
   if (!lua_isnil(L, 2)) {  /* function? */
     int res;
@@ -216,8 +237,38 @@ resume:
     s->s = 0;
     return res;
   }
-  else  /* a < b? */
-    return lua_lessthan(L, a, b);
+  else { /* a < b? */
+    /* return lua_lessthan(L, a, b); */
+    int res;
+    int t1 = lua_type(L, a);
+    int t2 = lua_type(L, b);
+    if (s->s) goto resume2;
+    if (t1 != t2)
+      return luaL_error(L, "attempt to compare %s with %s", lua_typename(L, t1), lua_typename(L, t2));
+    else if (t1 == LUA_TNUMBER) 
+      return lua_tonumber(L, a) < lua_tonumber(L, b);
+    else if (t1 == LUA_TSTRING)
+      return l_strcmp(L, a, b) < 0;
+    else if (luaL_getmetafield(L, a, "__lt")) {
+      if (luaL_getmetafield(L, b-1, "__lt")) {
+        if (lua_rawequal(L, -2, -1)) {
+          s->s = ss;
+          lua_pop(L, 1);
+          lua_pushvalue(L, a-1);  /* -1 to compensate function */
+          lua_pushvalue(L, b-2);  /* -2 to compensate function and `a' */
+          lua_vcall(L, 2, 1, s);
+resume2:
+          res = lua_toboolean(L, -1);
+          lua_pop(L, 1);
+          s->s = 0;
+          return res;
+        }
+        lua_pop(L, 1);
+      }
+      lua_pop(L, 1);
+    }
+    return luaL_error(L, "attempt to compare two %s values", lua_typename(L, t1));
+  }
 }
 
 static void auxsort (lua_State *L, struct table_sort_state * s, struct table_sort_args * a, int m) {
@@ -299,7 +350,7 @@ resume5:
       s->j=s->i+1; s->i=a->u; a->u=s->j-2;
     }
     a->next = (struct table_sort_args*)alloc(ud, NULL, 0, sizeof(struct table_sort_args));
-    a->next->l = s->j, a->next->u = s->i;
+    a->next->l = s->j; a->next->u = s->i;
     a->next->next = NULL;
     auxsort(L, s, a->next, m + 1);  /* call recursively the smaller one */
     alloc(ud, a->next, sizeof(struct table_sort_args), 0);
@@ -310,10 +361,11 @@ resume5:
 
 static int sort (lua_State *L) {
   struct table_sort_state * s;
+  struct table_sort_args *a, *aa;
   int n;
   void * ud = NULL;
   lua_Alloc alloc = lua_getallocf(L, &ud);
-  if (lua_icontext(L) > 0) {
+  if (lua_vcontext(L)) {
     s = (struct table_sort_state*)lua_vcontext(L);
     goto resume;
   }
@@ -330,7 +382,12 @@ static int sort (lua_State *L) {
   s->s = s->d = s->i = s->j = 0;
 resume:
   auxsort(L, s, s->args, 1);
-  for (struct table_sort_args* a = s->args, *aa = a; a != NULL; aa = a, a = a->next, alloc(ud, aa, sizeof(struct table_sort_args), 0)) ;
+  a = s->args;
+  while (a) {
+    aa = a;
+    a = a->next;
+    alloc(ud, aa, sizeof(struct table_sort_args), 0);
+  }
   alloc(ud, s, sizeof(struct table_sort_state), 0);
   return 0;
 }
@@ -366,7 +423,7 @@ static int tunpack (lua_State *L) {
 }
 
 
-static const luaL_Reg tab_funcs[] = {
+const luaL_Reg tab_funcs[] = {
   {"concat", tconcat},
   {"foreach", foreach},
   {"foreachi", foreachi},
@@ -383,7 +440,10 @@ static const luaL_Reg tab_funcs[] = {
 
 
 LUALIB_API int luaopen_table (lua_State *L) {
+#if LUA_OPTIMIZE_MEMORY > 0
+  return 0;
+#else
   luaL_register(L, LUA_TABLIBNAME, tab_funcs);
   return 1;
+#endif
 }
-
diff --git a/src/ltm.c b/src/ltm.c
index c27f0f6..e740695 100644
--- a/src/ltm.c
+++ b/src/ltm.c
@@ -21,7 +21,7 @@
 
 
 const char *const luaT_typenames[] = {
-  "nil", "boolean", "userdata", "number",
+  "nil", "boolean", "table", "function", "userdata", "number",
   "string", "table", "function", "userdata", "thread",
   "proto", "upval"
 };
diff --git a/src/lua.c b/src/lua.c
index 3a46609..670b1de 100644
--- a/src/lua.c
+++ b/src/lua.c
@@ -45,6 +45,7 @@ static void print_usage (void) {
   "Available options are:\n"
   "  -e stat  execute string " LUA_QL("stat") "\n"
   "  -l name  require library " LUA_QL("name") "\n"
+  "  -m limit set memory limit. (units are in Kbytes)\n"
   "  -i       enter interactive mode after executing " LUA_QL("script") "\n"
   "  -v       show version information\n"
   "  --       stop handling options\n"
@@ -278,6 +279,7 @@ static int collectargs (char **argv, int *pi, int *pv, int *pe) {
         break;
       case 'e':
         *pe = 1;  /* go through */
+      case 'm':   /* go through */
       case 'l':
         if (argv[i][2] == '\0') {
           i++;
@@ -305,6 +307,15 @@ static int runargs (lua_State *L, char **argv, int n) {
           return 1;
         break;
       }
+      case 'm': {
+        const char *limit = argv[i] + 2;
+        int memlimit=0;
+        if (*limit == '\0') limit = argv[++i];
+        lua_assert(limit != NULL);
+        memlimit = atoi(limit);
+        lua_gc(L, LUA_GCSETMEMLIMIT, memlimit);
+        break;
+      }
       case 'l': {
         const char *filename = argv[i] + 2;
         if (*filename == '\0') filename = argv[++i];
diff --git a/src/lua.h b/src/lua.h
index 75c9692..86b973d 100644
--- a/src/lua.h
+++ b/src/lua.h
@@ -17,7 +17,7 @@
 
 
 #define LUA_VERSION	"Lua 5.1"
-#define LUA_RELEASE	"Lua 5.1.5"
+#define LUA_RELEASE	"Lua 5.1.5 TEST"
 #define LUA_VERSION_NUM	501
 #define LUA_COPYRIGHT	"Copyright (C) 1994-2012 Lua.org, PUC-Rio"
 #define LUA_AUTHORS 	"R. Ierusalimschy, L. H. de Figueiredo & W. Celes"
@@ -74,15 +74,15 @@ typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
 
 #define LUA_TNIL		0
 #define LUA_TBOOLEAN		1
-#define LUA_TLIGHTUSERDATA	2
-#define LUA_TNUMBER		3
-#define LUA_TSTRING		4
-#define LUA_TTABLE		5
-#define LUA_TFUNCTION		6
-#define LUA_TUSERDATA		7
-#define LUA_TTHREAD		8
-
-
+#define LUA_TROTABLE  2
+#define LUA_TLIGHTFUNCTION  3
+#define LUA_TLIGHTUSERDATA	4
+#define LUA_TNUMBER		5
+#define LUA_TSTRING		6
+#define LUA_TTABLE		7
+#define LUA_TFUNCTION		8
+#define LUA_TUSERDATA		9
+#define LUA_TTHREAD		10
 
 /* minimum Lua stack available to a C function */
 #define LUA_MINSTACK	20
@@ -95,6 +95,9 @@ typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
 #include LUA_USER_H
 #endif
 
+#if defined(LUA_OPTIMIZE_DEBUG) && LUA_OPTIMIZE_DEBUG == 0
+#undef LUA_OPTIMIZE_DEBUG
+#endif
 
 /* type of numbers in Lua */
 typedef LUA_NUMBER lua_Number;
@@ -170,6 +173,8 @@ LUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
 LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
 LUA_API void  (lua_pushboolean) (lua_State *L, int b);
 LUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);
+LUA_API void  (lua_pushlightfunction) (lua_State *L, void *p);
+LUA_API void  (lua_pushrotable) (lua_State *L, void *p);
 LUA_API int   (lua_pushthread) (lua_State *L);
 
 
@@ -242,6 +247,8 @@ LUA_API int  (lua_status) (lua_State *L);
 #define LUA_GCSTEP		5
 #define LUA_GCSETPAUSE		6
 #define LUA_GCSETSTEPMUL	7
+#define LUA_GCSETMEMLIMIT	8
+#define LUA_GCGETMEMLIMIT	9
 
 LUA_API int (lua_gc) (lua_State *L, int what, int data);
 
@@ -283,6 +290,7 @@ LUA_API void  (lua_setlockstate) (lua_State *L, int enabled); /* enables/disable
 #define lua_strlen(L,i)		lua_objlen(L, (i))
 
 #define lua_isfunction(L,n)	(lua_type(L, (n)) == LUA_TFUNCTION)
+#define lua_islightfunction(L,n) (lua_type(L, (n)) == LUA_TLIGHTFUNCTION)
 #define lua_istable(L,n)	(lua_type(L, (n)) == LUA_TTABLE)
 #define lua_islightuserdata(L,n)	(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)
 #define lua_isnil(L,n)		(lua_type(L, (n)) == LUA_TNIL)
diff --git a/src/luaconf.h b/src/luaconf.h
index 6423bfe..97e3a72 100644
--- a/src/luaconf.h
+++ b/src/luaconf.h
@@ -370,6 +370,16 @@
 
 
 
+/*
+@@ LUA_STRESS_EMERGENCY_GC enables stress testing code for the Emergency GC.
+** CHANGE it to defined if you want to test for Emergency GC related bugs.
+** Note that this will make the Lua vm very slow, since it will force a
+** full GC on every new allocation.
+*/
+#undef LUA_STRESS_EMERGENCY_GC
+
+
+
 /*
 @@ luai_apicheck is the assert macro used by the Lua-C API.
 ** CHANGE luai_apicheck if you want Lua to perform some checks in the
@@ -759,7 +769,25 @@ union luai_Cast { double l_d; long l_l; };
 ** without modifying the main part of the file.
 */
 
+#define LUA_MAX_ROTABLE_NAME      32
+
+/* LUA_OPTIMIZE_MEMORY:
+   0 - no optimizations
+   1 - optimize while maitaining full compatibility with the test suite
+   2 - aggresive optimizations (breaks compatibility with some tests)
+*/
+#ifndef LUA_OPTIMIZE_MEMORY
+#define LUA_OPTIMIZE_MEMORY				2
+#endif
+
+#if LUA_OPTIMIZE_MEMORY == 2 && LUA_USE_POPEN
+#error "Pipes not supported in aggresive optimization mode (LUA_OPTIMIZE_MEMORY=2)"
+#endif
+
+#define LUA_OPTIMIZE_DEBUG 3
 
+//#include <assert.h>
+//#define lua_assert(k) (assert((k)))
 
 #endif
 
diff --git a/src/lundump.c b/src/lundump.c
index 4e76e0c..25d2220 100644
--- a/src/lundump.c
+++ b/src/lundump.c
@@ -117,10 +117,10 @@ static void LoadConstants(LoadState* S, Proto* f)
    case LUA_TBOOLEAN:
    	setbvalue(o,LoadChar(S)!=0);
 	break;
-   case LUA_TNUMBER:
+   case 3:
 	setnvalue(o,LoadNumber(S));
 	break;
-   case LUA_TSTRING:
+   case 4:
 	setsvalue2n(S->L,o,LoadString(S));
 	break;
    default:
@@ -139,9 +139,18 @@ static void LoadDebug(LoadState* S, Proto* f)
 {
  int i,n;
  n=LoadInt(S);
+#ifdef LUA_OPTIMIZE_DEBUG
+ if(n) {
+   f->packedlineinfo=luaM_newvector(S->L,n,unsigned char);
+   LoadBlock(S,f->packedlineinfo,n);
+ } else {
+   f->packedlineinfo=NULL;
+ }
+#else
  f->lineinfo=luaM_newvector(S->L,n,int);
  f->sizelineinfo=n;
  LoadVector(S,f->lineinfo,n,sizeof(int));
+#endif
  n=LoadInt(S);
  f->locvars=luaM_newvector(S->L,n,LocVar);
  f->sizelocvars=n;
diff --git a/src/lvm.c b/src/lvm.c
index bc3e3d6..58fc2c7 100644
--- a/src/lvm.c
+++ b/src/lvm.c
@@ -9,6 +9,8 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include <stddef.h>  /*DEBUG */ 
+
 #define lvm_c
 #define LUA_CORE
 
@@ -25,8 +27,7 @@
 #include "ltable.h"
 #include "ltm.h"
 #include "lvm.h"
-
-
+#include "lrotable.h"
 
 /* limit for table tag-method chains (to avoid loops) */
 #define MAXTAGLOOP	100
@@ -49,9 +50,10 @@ int luaV_tostring (lua_State *L, StkId obj) {
     return 0;
   else {
     char s[LUAI_MAXNUMBER2STR];
+    ptrdiff_t objr = savestack(L, obj);
     lua_Number n = nvalue(obj);
     lua_number2str(s, n);
-    setsvalue2s(L, obj, luaS_new(L, s));
+    setsvalue2s(L, restorestack(L, objr), luaS_new(L, s));
     return 1;
   }
 }
@@ -105,12 +107,33 @@ static void callTM (lua_State *L, const TValue *f, const TValue *p1,
   luaD_call(L, L->top - 4, 0, 0);
 }
 
+static void lua_getcstr(char *dest, const TString *src, size_t maxsize) {
+  if (src->tsv.len+1 > maxsize)
+    dest[0] = '\0';
+  else {
+    memcpy(dest, getstr(src), src->tsv.len);
+    dest[src->tsv.len] = '\0';
+  } 
+}
 
-void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
+void luaV_gettable(lua_State *L, const TValue *t, TValue *key, StkId val) {
   int loop;
   for (loop = 0; loop < MAXTAGLOOP; loop++) {
     const TValue *tm;
-    if (ttistable(t)) {  /* `t' is a table? */
+    if (ttisrotable(t)) {
+      if (ttisstring(key)) {
+        char keyname[LUA_MAX_ROTABLE_NAME + 1];
+        lu_byte keytype;
+        lua_getcstr(keyname, rawtsvalue(key), LUA_MAX_ROTABLE_NAME);      
+        luaR_result res = luaR_findentry(rvalue(t), keyname, &keytype);
+        if (keytype == LUA_TLIGHTFUNCTION)
+          setfvalue(val, (void*)(size_t)res)
+        else if (keytype == LUA_TNUMBER)
+          setnvalue(val, (lua_Number)res)
+        else setnilvalue(val);
+      } else setnilvalue(val);
+      return;
+    } else if (ttistable(t)) {  /* `t' is a table? */
       Table *h = hvalue(t);
       const TValue *res = luaH_get(h, key); /* do a primitive get */
       if (!ttisnil(res) ||  /* result is no nil? */
@@ -122,7 +145,7 @@ void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
     }
     else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_INDEX)))
       luaG_typeerror(L, t, "index");
-    if (ttisfunction(tm)) {
+    if (ttisfunction(tm) || ttislightfunction(tm)) {
       callTMres(L, val, tm, t, key);
       return;
     }
@@ -135,6 +158,9 @@ void luaV_gettable (lua_State *L, const TValue *t, TValue *key, StkId val) {
 void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
   int loop;
   TValue temp;
+  setnilvalue(L->top);
+  L->top++;
+  fixedstack(L);
   for (loop = 0; loop < MAXTAGLOOP; loop++) {
     const TValue *tm;
     if (ttistable(t)) {  /* `t' is a table? */
@@ -142,6 +168,8 @@ void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
       TValue *oldval = luaH_set(L, h, key); /* do a primitive set */
       if (!ttisnil(oldval) ||  /* result is no nil? */
           (tm = fasttm(L, h->metatable, TM_NEWINDEX)) == NULL) { /* or no TM? */
+        L->top--;
+        unfixedstack(L);
         setobj2t(L, oldval, val);
         h->flags = 0;
         luaC_barriert(L, h, val);
@@ -149,15 +177,20 @@ void luaV_settable (lua_State *L, const TValue *t, TValue *key, StkId val) {
       }
       /* else will try the tag method */
     }
+    else if (ttisrotable(t))  /* `t' is a read-only table? */
+      luaG_typeerror(L, t, "modify");
     else if (ttisnil(tm = luaT_gettmbyobj(L, t, TM_NEWINDEX)))
       luaG_typeerror(L, t, "index");
     if (ttisfunction(tm)) {
+      L->top--;
+      unfixedstack(L);
       callTM(L, tm, t, key, val);
       return;
     }
     /* else repeat with `tm' */
     setobj(L, &temp, tm);  /* avoid pointing inside table (may rehash) */
     t = &temp;
+    setobj2s(L, L->top-1, t);  /* need to protect value from EGC. */
   }
   luaG_runerror(L, "loop in settable");
 }
@@ -260,7 +293,10 @@ int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
     case LUA_TNIL: return 1;
     case LUA_TNUMBER: return luai_numeq(nvalue(t1), nvalue(t2));
     case LUA_TBOOLEAN: return bvalue(t1) == bvalue(t2);  /* true must be 1 !! */
-    case LUA_TLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);
+    case LUA_TLIGHTUSERDATA: 
+    case LUA_TROTABLE:
+    case LUA_TLIGHTFUNCTION:
+      return pvalue(t1) == pvalue(t2);
     case LUA_TUSERDATA: {
       if (uvalue(t1) == uvalue(t2)) return 1;
       tm = get_compTM(L, uvalue(t1)->metatable, uvalue(t2)->metatable,
@@ -281,14 +317,19 @@ int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2) {
 
 
 void luaV_concat (lua_State *L, int total, int last) {
+  lu_mem max_sizet = MAX_SIZET;
+  if (G(L)->memlimit < max_sizet) max_sizet = G(L)->memlimit;
   do {
     StkId top = L->base + last + 1;
     int n = 2;  /* number of elements handled in this pass (at least 2) */
     if (!(ttisstring(top-2) || ttisnumber(top-2)) || !tostring(L, top-1)) {
       setpvalue(L->top, (void *)(ptrdiff_t)(last - 1));  /* for luaV_resume */
       L->top++;
-      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT))
+      if (!call_binTM(L, top-2, top-1, top-2, TM_CONCAT)) {
+        /* restore 'top' pointer, since stack might have been reallocted */
+        top = L->base + last + 1;
         luaG_concaterror(L, top-2, top-1);
+      }
       L->top--;
     } else if (tsvalue(top-1)->len == 0)  /* second op is empty? */
       (void)tostring(L, top - 2);  /* result is first op (as string) */
@@ -297,12 +338,14 @@ void luaV_concat (lua_State *L, int total, int last) {
       size_t tl = tsvalue(top-1)->len;
       char *buffer;
       int i;
+      fixedstack(L);
       /* collect total length */
       for (n = 1; n < total && tostring(L, top-n-1); n++) {
         size_t l = tsvalue(top-n-1)->len;
         if (l >= MAX_SIZET - tl) luaG_runerror(L, "string length overflow");
         tl += l;
       }
+      G(L)->buff.n = tl;
       buffer = luaZ_openspace(L, &G(L)->buff, tl);
       tl = 0;
       for (i=n; i>0; i--) {  /* concat all strings */
@@ -311,6 +354,8 @@ void luaV_concat (lua_State *L, int total, int last) {
         tl += l;
       }
       setsvalue2s(L, top-n, luaS_newlstr(L, buffer, tl));
+      luaZ_resetbuffer(&G(L)->buff);
+      unfixedstack(L);
     }
     total -= n-1;  /* got `n' strings to create 1 new */
     last -= n-1;
@@ -342,8 +387,13 @@ static void Arith (lua_State *L, StkId ra, const TValue *rb,
       default: lua_assert(0); break;
     }
   }
-  else if (!call_binTM(L, rb, rc, ra, op))
-    luaG_aritherror(L, rb, rc);
+  else {
+    ptrdiff_t br = savestack(L, rb);
+    ptrdiff_t cr = savestack(L, rc);
+    if (!call_binTM(L, rb, rc, ra, op)) {
+      luaG_aritherror(L, restorestack(L, br), restorestack(L, cr));
+    }
+  }
 }
 
 
@@ -403,8 +453,8 @@ int luaV_execute (lua_State *L) {
         luaC_checkGC(L);
         int concat = 0;
         if (G(L)->haltmessage) {
-          if (!clvalue(L->ci->func)->c.isC && clvalue(L->ci->func)->l.p->lineinfo[pcRel(cast(const Instruction *, L->ctx), ci_func(L->ci)->l.p)] > 0) {
-            char wheretemp[LUA_IDSIZE+20];  /* 20 extra characters should be enough for line number + 4 characters (:: <\0>) */
+          /*if (!clvalue(L->ci->func)->c.isC && clvalue(L->ci->func)->l.p->lineinfo[pcRel(cast(const Instruction *, L->ctx), ci_func(L->ci)->l.p)] > 0) {
+            char wheretemp[LUA_IDSIZE+20];  /* 20 extra characters should be enough for line number + 4 characters (:: <\0>) * /
             size_t wheresize;
             luaO_chunkid(wheretemp, getstr(clvalue(L->ci->func)->l.p->source), LUA_IDSIZE);
             wheresize = strlen(wheretemp);
@@ -412,7 +462,7 @@ int luaV_execute (lua_State *L) {
             setsvalue2s(L, L->top, luaS_newlstr(L, wheretemp, wheresize));
             L->top++;
             concat = 1;
-          }
+          }*/
           setsvalue2s(L, L->top, luaS_newlstr(L, G(L)->haltmessage, strlen(G(L)->haltmessage)));
         }
         else {setnilvalue(L->top);}
@@ -468,6 +518,21 @@ int luaV_execute (lua_State *L) {
         sethvalue(L, &g, cl->env);
         lua_assert(ttisstring(rb));
         Protect(luaV_gettable(L, &g, rb, ra));
+#if LUA_OPTIMIZE_MEMORY > 0
+        if (ttisnil(ra)) {
+          /* If failed, try to look for a rotable with this name */
+          char keyname[LUA_MAX_ROTABLE_NAME + 1];
+          lu_byte keytype;
+          lua_getcstr(keyname, rawtsvalue(rb), LUA_MAX_ROTABLE_NAME);
+          luaR_result res = luaR_findglobal(keyname, &keytype);
+          if (keytype == LUA_TROTABLE)
+            setrvalue(ra, (void*)(size_t)res)
+          else if (keytype == LUA_TLIGHTFUNCTION)
+            setfvalue(ra, (void*)(size_t)res)
+          else if (keytype == LUA_TNUMBER)
+            setnvalue(ra, (lua_Number)res)     
+        }
+#endif
         continue;
       }
       case OP_GETTABLE: {
@@ -494,7 +559,9 @@ int luaV_execute (lua_State *L) {
       case OP_NEWTABLE: {
         int b = GETARG_B(i);
         int c = GETARG_C(i);
-        sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
+        Table *h;
+        Protect(h = luaH_new(L, luaO_fb2int(b), luaO_fb2int(c)));
+        sethvalue(L, RA(i), h);
         Protect(luaC_checkGC(L));
         continue;
       }
@@ -559,9 +626,10 @@ int luaV_execute (lua_State *L) {
             break;
           }
           default: {  /* try metamethod */
+            ptrdiff_t br = savestack(L, rb);
             Protect(
               if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN))
-                luaG_typeerror(L, rb, "get length of");
+                luaG_typeerror(L, restorestack(L, br), "get length of");
             )
           }
         }
@@ -734,6 +802,7 @@ int luaV_execute (lua_State *L) {
         int c = GETARG_C(i);
         int last;
         Table *h;
+        fixedstack(L);
         if (n == 0) {
           n = cast_int(L->top - ra) - 1;
           L->top = L->ci->top;
@@ -749,6 +818,7 @@ int luaV_execute (lua_State *L) {
           setobj2t(L, luaH_setnum(L, h, last--), val);
           luaC_barriert(L, h, val);
         }
+        unfixedstack(L);
         continue;
       }
       case OP_CLOSE: {
@@ -761,7 +831,9 @@ int luaV_execute (lua_State *L) {
         int nup, j;
         p = cl->p->p[GETARG_Bx(i)];
         nup = p->nups;
+        fixedstack(L);
         ncl = luaF_newLclosure(L, nup, cl->env);
+        setclvalue(L, ra, ncl);
         ncl->l.p = p;
         for (j=0; j<nup; j++, pc++) {
           if (GET_OPCODE(*pc) == OP_GETUPVAL)
@@ -771,7 +843,7 @@ int luaV_execute (lua_State *L) {
             ncl->l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc));
           }
         }
-        setclvalue(L, ra, ncl);
+        unfixedstack(L);
         Protect(luaC_checkGC(L));
         continue;
       }
diff --git a/src/lvm.h b/src/lvm.h
index 32da167..02ec299 100644
--- a/src/lvm.h
+++ b/src/lvm.h
@@ -25,11 +25,11 @@
 #define SAVEPC(L, pc)	L->ctx = cast(void *, (pc))
 
 
-
 LUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);
 LUAI_FUNC int luaV_equalval (lua_State *L, const TValue *t1, const TValue *t2);
 LUAI_FUNC const TValue *luaV_tonumber (const TValue *obj, TValue *n);
 LUAI_FUNC int luaV_tostring (lua_State *L, StkId obj);
+
 LUAI_FUNC void luaV_gettable (lua_State *L, const TValue *t, TValue *key,
                                             StkId val);
 LUAI_FUNC void luaV_settable (lua_State *L, const TValue *t, TValue *key,
diff --git a/src/lzio.h b/src/lzio.h
index 51d695d..d6073d7 100644
--- a/src/lzio.h
+++ b/src/lzio.h
@@ -27,7 +27,7 @@ typedef struct Mbuffer {
   size_t buffsize;
 } Mbuffer;
 
-#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)
+#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->n = 0, (buff)->buffsize = 0)
 
 #define luaZ_buffer(buff)	((buff)->buffer)
 #define luaZ_sizebuffer(buff)	((buff)->buffsize)
