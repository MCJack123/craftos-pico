extern "C" {
#include <lua.h>
#include <lauxlib.h>
}
#include "fs_handle.h"
#include "FileEntry.hpp"
#include <algorithm>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

extern const FileEntry standaloneROM;

// TODO: Add actual filesystem access once SD/USB is implemented

std::string fixpath(const char * str) {
    std::string retval;
    retval.reserve(strlen(str));
    while (*str) {
        while (*str == '/') str++;
        while (*str && *str != '/') retval += *str++;
        if (*str) retval += '/';
    }
    return retval;
}

static void err(lua_State *L, std::string path, const char * err) {
    luaL_error(L, "%s: %s", path.c_str(), err);
}

static bool stringcompare(const char * a, const char * b) {
    if (a == NULL) return false;
    else if (b == NULL) return true;
    return strcmp(a, b) < 0;
}

int fs_list(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find("rom") == 0) {
        const FileEntry * e = &standaloneROM;
        size_t start = path.find('/');
        while (start != std::string::npos) {
            size_t next = path.find('/', start + 1);
            e = &(*e)[path.substr(start + 1, next - start - 1)];
            if (e == &FileEntry::NULL_ENTRY) err(L, path, "No such file");
            if (!e->isDir) err(L, path, "Not a directory");
            start = next;
        }
        const char ** keys = new const char*[e->size()];
        for (int i = 0; i < e->size(); i++) keys[i] = e->dir[i].name;
        std::sort(keys, keys + e->size(), stringcompare);
        lua_createtable(L, e->size(), 0);
        for (int i = 0; i < e->size(); i++) {
            lua_pushstring(L, keys[i]);
            lua_rawseti(L, -2, i + 1);
        }
        delete[] keys;
    } else {
        lua_newtable(L);
        int found = 0;
        for (const char * s = path.c_str(); *s; s++) {if (*s != '/') {found = 1; break;}}
        if (!found) {
            lua_pushstring(L, "rom");
            lua_rawseti(L, -2, 1);
        }
    }
    return 1;
}

int fs_exists(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find("rom/") == 0) {
        const FileEntry * e = &standaloneROM;
        size_t start = path.find('/');
        bool found = true;
        while (start != std::string::npos) {
            if (!e->isDir) {
                found = false;
                break;
            }
            size_t next = path.find('/', start + 1);
            e = &(*e)[path.substr(start + 1, next - start - 1)];
            if (e == &FileEntry::NULL_ENTRY) {
                found = false;
                break;
            }
            start = next;
        }
        lua_pushboolean(L, found);
    } else lua_pushboolean(L, path == "" || path == "rom");
    return 1;
}

int fs_isDir(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find("rom/") == 0) {
        const FileEntry * e = &standaloneROM;
        size_t start = path.find('/');
        bool found = true;
        while (start != std::string::npos) {
            if (!e->isDir) {
                found = false;
                break;
            }
            size_t next = path.find('/', start + 1);
            e = &(*e)[path.substr(start + 1, next - start - 1)];
            if (e == &FileEntry::NULL_ENTRY) {
                found = false;
                break;
            }
            start = next;
        }
        lua_pushboolean(L, found && e->isDir);
    } else lua_pushboolean(L, path == "" || path == "rom");
    return 1;
}

int fs_isReadOnly(lua_State *L) {
    lua_pushboolean(L, true);
    return 1;
}

int fs_getName(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find('/') == std::string::npos) lua_pushvalue(L, 1);
    else lua_pushlstring(L, path.substr(path.find_last_of('/') + 1).c_str(), path.substr(path.find_last_of('/') + 1).size());
    return 1;
}

int fs_getDrive(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find("rom") == 0) lua_pushstring(L, "rom");
    else lua_pushstring(L, "hdd");
    return 1;
}

int fs_getSize(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find("rom/") == 0) {
        const FileEntry * e = &standaloneROM;
        size_t start = path.find('/');
        bool found = true;
        while (start != std::string::npos) {
            if (!e->isDir) err(L, path, "Not a directory");
            size_t next = path.find('/', start + 1);
            e = &(*e)[path.substr(start + 1, next - start - 1)];
            if (e == &FileEntry::NULL_ENTRY) err(L, path, "No such file");
            start = next;
        }
        if (e->isDir) err(L, path, "No such file");
        lua_pushinteger(L, e->size());
    } else err(L, path, "No such file");
    return 1;
}

int fs_getFreeSpace(lua_State *L) {
    lua_pushinteger(L, 0);
    return 1;
}

int fs_makeDir(lua_State *L) {
    err(L, luaL_tostring(L, 1), "Permission denied");
    return 0;
}

int fs_move(lua_State *L) {
    err(L, luaL_tostring(L, 1), "Permission denied");
    return 0;
}

int fs_copy(lua_State *L) {
    err(L, luaL_tostring(L, 1), "Permission denied");
    return 0;
}

int fs_delete(lua_State *L) {
    err(L, luaL_tostring(L, 1), "Permission denied");
    return 0;
}

int fs_combine(lua_State *L) {
    std::string base = fixpath(luaL_checkstring(L, 1));
    for (int i = 2; i <= lua_gettop(L); i++) base += "/" + fixpath(luaL_checkstring(L, i));
    lua_pushlstring(L, base.c_str(), base.size());
    return 1;
}

int fs_open(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    const char * mode = luaL_checkstring(L, 2);
    if (path.find("rom/") == 0) {
        const FileEntry * e = &standaloneROM;
        size_t start = path.find('/');
        bool found = true;
        while (start != std::string::npos) {
            if (!e->isDir) err(L, path, "Not a directory");
            size_t next = path.find('/', start + 1);
            e = &(*e)[path.substr(start + 1, next - start - 1)];
            if (e == &FileEntry::NULL_ENTRY) err(L, path, "No such file");
            start = next;
        }
        if (e->isDir) err(L, path, "No such file");
        
        lua_newuserdata(L, sizeof(stream_t));
        stream_t * strm = (stream_t*)lua_touserdata(L, -1);
        strm->base = strm->cur = e->data;
        strm->eof = e->data + e->sz;
        strm->open = true;

        int pos = lua_gettop(L);
        lua_newtable(L);
        lua_pushstring(L, "close");
        lua_pushvalue(L, pos);
        lua_pushcclosure(L, handle_istream_close, 1);
        lua_settable(L, -3);
        if (strcmp(mode, "r") == 0) {
            lua_pushstring(L, "readAll");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_readAll, 1);
            lua_settable(L, -3);

            lua_pushstring(L, "readLine");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_readLine, 1);
            lua_settable(L, -3);

            lua_pushstring(L, "read");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_readChar, 1);
            lua_settable(L, -3);
        } else if (strcmp(mode, "rb") == 0) {
            lua_pushstring(L, "read");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_readByte, 1);
            lua_settable(L, -3);

            lua_pushstring(L, "readAll");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_readAllByte, 1);
            lua_settable(L, -3);

            lua_pushstring(L, "seek");
            lua_pushvalue(L, pos);
            lua_pushcclosure(L, handle_istream_seek, 1);
            lua_settable(L, -3);
        } else if (strcmp(mode, "w") == 0 || strcmp(mode, "a") == 0 || strcmp(mode, "wb") == 0 || strcmp(mode, "ab") == 0) {
            err(L, path, "Permission denied");
        } else {
            err(L, mode, "Invalid mode");
        }
    } else err(L, path, "No such file");
    return 1;
}

int fs_find(lua_State *L) {
    lua_newtable(L);
    return 1;
}

int fs_getDir(lua_State *L) {
    std::string path = fixpath(luaL_checkstring(L, 1));
    if (path.find('/') == std::string::npos) lua_pushvalue(L, 1);
    else lua_pushlstring(L, path.substr(0, path.find_last_of('/')).c_str(), path.substr(0, path.find_last_of('/')).size());
    return 1;
}

// We put fs.complete in the C section to allow fs to be an rotable.
// I don't really feel like rewriting the whole function; instead,
// we'll just embed the (compiled) Lua code, load it on first
// execution, and run it with the required closure.

static const char fs_complete_func[] = {
  0x1b, 0x4c, 0x75, 0x61, 0x51, 0x00, 0x01, 0x04, 0x04, 0x04, 0x08, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00,
  0x01, 0x04, 0x00, 0x15, 0xe1, 0x00, 0x00, 0x00, 0x05, 0x01, 0x00, 0x00,
  0x40, 0x01, 0x00, 0x00, 0x1c, 0x81, 0x00, 0x01, 0x57, 0x40, 0x40, 0x02,
  0x16, 0x00, 0x02, 0x80, 0x05, 0x81, 0x00, 0x00, 0x41, 0xc1, 0x00, 0x00,
  0x85, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00, 0x9c, 0x81, 0x00, 0x01,
  0xc1, 0x01, 0x01, 0x00, 0x55, 0xc1, 0x81, 0x02, 0x81, 0x41, 0x01, 0x00,
  0x1c, 0x41, 0x80, 0x01, 0x05, 0x01, 0x00, 0x00, 0x40, 0x01, 0x80, 0x00,
  0x1c, 0x81, 0x00, 0x01, 0x57, 0x40, 0x40, 0x02, 0x16, 0x00, 0x02, 0x80,
  0x05, 0x81, 0x00, 0x00, 0x41, 0x81, 0x01, 0x00, 0x85, 0x01, 0x00, 0x00,
  0xc0, 0x01, 0x80, 0x00, 0x9c, 0x81, 0x00, 0x01, 0xc1, 0x01, 0x01, 0x00,
  0x55, 0xc1, 0x81, 0x02, 0x81, 0x41, 0x01, 0x00, 0x1c, 0x41, 0x80, 0x01,
  0x57, 0xc0, 0x41, 0x01, 0x16, 0x40, 0x03, 0x80, 0x05, 0x01, 0x00, 0x00,
  0x40, 0x01, 0x00, 0x01, 0x1c, 0x81, 0x00, 0x01, 0x57, 0x00, 0x42, 0x02,
  0x16, 0x00, 0x02, 0x80, 0x05, 0x81, 0x00, 0x00, 0x41, 0x41, 0x02, 0x00,
  0x85, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x01, 0x9c, 0x81, 0x00, 0x01,
  0xc1, 0x01, 0x01, 0x00, 0x55, 0xc1, 0x81, 0x02, 0x81, 0x41, 0x01, 0x00,
  0x1c, 0x41, 0x80, 0x01, 0x57, 0xc0, 0xc1, 0x01, 0x16, 0x40, 0x03, 0x80,
  0x05, 0x01, 0x00, 0x00, 0x40, 0x01, 0x80, 0x01, 0x1c, 0x81, 0x00, 0x01,
  0x57, 0x00, 0x42, 0x02, 0x16, 0x00, 0x02, 0x80, 0x05, 0x81, 0x00, 0x00,
  0x41, 0x81, 0x02, 0x00, 0x85, 0x01, 0x00, 0x00, 0xc0, 0x01, 0x80, 0x01,
  0x9c, 0x81, 0x00, 0x01, 0xc1, 0x01, 0x01, 0x00, 0x55, 0xc1, 0x81, 0x02,
  0x81, 0x41, 0x01, 0x00, 0x1c, 0x41, 0x80, 0x01, 0x17, 0xc0, 0x42, 0x01,
  0x16, 0x00, 0x00, 0x80, 0x82, 0x40, 0x00, 0x00, 0x82, 0x00, 0x80, 0x00,
  0x17, 0xc0, 0xc2, 0x01, 0x16, 0x00, 0x00, 0x80, 0xc2, 0x40, 0x00, 0x00,
  0xc2, 0x00, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x41, 0x01, 0x03, 0x00,
  0x85, 0x41, 0x00, 0x00, 0x86, 0x41, 0x43, 0x03, 0xc0, 0x01, 0x00, 0x00,
  0x01, 0x82, 0x03, 0x00, 0x40, 0x02, 0x80, 0x02, 0x9c, 0x81, 0x00, 0x02,
  0x17, 0x00, 0x43, 0x03, 0x16, 0x40, 0x00, 0x80, 0x01, 0xc1, 0x03, 0x00,
  0x41, 0x41, 0x01, 0x00, 0xc3, 0x01, 0x80, 0x03, 0xda, 0x41, 0x00, 0x00,
  0x16, 0x00, 0x07, 0x80, 0x05, 0x42, 0x00, 0x00, 0x06, 0x42, 0x43, 0x04,
  0x40, 0x02, 0x00, 0x00, 0x81, 0x82, 0x03, 0x00, 0xc0, 0x02, 0x80, 0x02,
  0x1c, 0x82, 0x00, 0x02, 0x1a, 0x02, 0x00, 0x00, 0x16, 0x40, 0x03, 0x80,
  0x45, 0x42, 0x00, 0x00, 0x46, 0x02, 0xc4, 0x04, 0x80, 0x02, 0x00, 0x00,
  0xc0, 0x02, 0x80, 0x02, 0x0d, 0x03, 0x43, 0x04, 0x5c, 0x82, 0x00, 0x02,
  0x85, 0x42, 0x04, 0x00, 0x86, 0x82, 0x44, 0x05, 0xc0, 0x02, 0x00, 0x02,
  0x00, 0x03, 0x80, 0x04, 0x9c, 0x82, 0x80, 0x01, 0x00, 0x01, 0x00, 0x05,
  0x4c, 0x01, 0x43, 0x04, 0x16, 0xc0, 0xf9, 0x7f, 0x45, 0x42, 0x00, 0x00,
  0x46, 0x02, 0xc4, 0x04, 0x80, 0x02, 0x00, 0x00, 0xc0, 0x02, 0x80, 0x02,
  0x5c, 0x82, 0x80, 0x01, 0xc0, 0x01, 0x80, 0x04, 0x16, 0x00, 0xf8, 0x7f,
  0x05, 0x42, 0x04, 0x00, 0x06, 0xc2, 0x44, 0x04, 0x40, 0x02, 0x00, 0x02,
  0x1c, 0x82, 0x00, 0x01, 0x1a, 0x02, 0x00, 0x00, 0x16, 0xc0, 0x19, 0x80,
  0x0a, 0x02, 0x00, 0x00, 0xda, 0x00, 0x00, 0x00, 0x16, 0x80, 0x01, 0x80,
  0x17, 0xc0, 0x43, 0x00, 0x16, 0x00, 0x01, 0x80, 0x45, 0x02, 0x05, 0x00,
  0x46, 0x42, 0xc5, 0x04, 0x80, 0x02, 0x00, 0x04, 0xc1, 0x82, 0x05, 0x00,
  0x5c, 0x42, 0x80, 0x01, 0x57, 0xc0, 0x43, 0x02, 0x16, 0x00, 0x06, 0x80,
  0x17, 0xc0, 0x43, 0x00, 0x16, 0x80, 0x02, 0x80, 0x45, 0x02, 0x05, 0x00,
  0x46, 0x42, 0xc5, 0x04, 0x80, 0x02, 0x00, 0x04, 0xda, 0x00, 0x00, 0x00,
  0x16, 0x80, 0x00, 0x80, 0xc1, 0xc2, 0x05, 0x00, 0xda, 0x42, 0x00, 0x00,
  0x16, 0x00, 0x00, 0x80, 0xc1, 0x02, 0x06, 0x00, 0x5c, 0x42, 0x80, 0x01,
  0x16, 0xc0, 0x02, 0x80, 0x17, 0x80, 0x45, 0x00, 0x16, 0x40, 0x02, 0x80,
  0x45, 0x02, 0x05, 0x00, 0x46, 0x42, 0xc5, 0x04, 0x80, 0x02, 0x00, 0x04,
  0xda, 0x00, 0x00, 0x00, 0x16, 0x80, 0x00, 0x80, 0xc1, 0x82, 0x05, 0x00,
  0xda, 0x42, 0x00, 0x00, 0x16, 0x00, 0x00, 0x80, 0xc1, 0x42, 0x06, 0x00,
  0x5c, 0x42, 0x80, 0x01, 0x45, 0x42, 0x04, 0x00, 0x46, 0x82, 0xc6, 0x04,
  0x80, 0x02, 0x00, 0x02, 0x5c, 0x82, 0x00, 0x01, 0x81, 0x02, 0x03, 0x00,
  0xd4, 0x02, 0x80, 0x04, 0x01, 0x03, 0x03, 0x00, 0xa0, 0x02, 0x0e, 0x80,
  0x86, 0x43, 0x83, 0x04, 0xd4, 0x03, 0x00, 0x07, 0x14, 0x04, 0x80, 0x03,
  0x19, 0xc0, 0x03, 0x08, 0x16, 0xc0, 0x0c, 0x80, 0xc5, 0x43, 0x00, 0x00,
  0xc6, 0x03, 0xc4, 0x07, 0x00, 0x04, 0x00, 0x07, 0x41, 0x04, 0x03, 0x00,
  0x94, 0x04, 0x80, 0x03, 0xdc, 0x83, 0x00, 0x02, 0x17, 0xc0, 0x81, 0x07,
  0x16, 0xc0, 0x0a, 0x80, 0xc5, 0x43, 0x04, 0x00, 0xc6, 0xc3, 0xc4, 0x07,
  0x05, 0x44, 0x04, 0x00, 0x06, 0x84, 0x44, 0x08, 0x40, 0x04, 0x00, 0x02,
  0x80, 0x04, 0x00, 0x07, 0x1c, 0x04, 0x80, 0x01, 0xdc, 0x83, 0x00, 0x00,
  0x05, 0x44, 0x00, 0x00, 0x06, 0x04, 0x44, 0x08, 0x40, 0x04, 0x00, 0x07,
  0x94, 0x04, 0x80, 0x03, 0x8c, 0x04, 0x43, 0x09, 0x1c, 0x84, 0x80, 0x01,
  0xda, 0x03, 0x00, 0x00, 0x16, 0x40, 0x04, 0x80, 0x45, 0x04, 0x05, 0x00,
  0x46, 0x44, 0xc5, 0x08, 0x80, 0x04, 0x00, 0x04, 0xc0, 0x04, 0x00, 0x08,
  0x01, 0xc5, 0x06, 0x00, 0xd5, 0x04, 0x85, 0x09, 0x5c, 0x44, 0x80, 0x01,
  0xda, 0x00, 0x00, 0x00, 0x16, 0x80, 0x04, 0x80, 0x54, 0x04, 0x00, 0x08,
  0x18, 0x40, 0x04, 0x8e, 0x16, 0xc0, 0x03, 0x80, 0x45, 0x04, 0x05, 0x00,
  0x46, 0x44, 0xc5, 0x08, 0x80, 0x04, 0x00, 0x04, 0xc0, 0x04, 0x00, 0x08,
  0x5c, 0x44, 0x80, 0x01, 0x16, 0x40, 0x02, 0x80, 0x9a, 0x00, 0x00, 0x00,
  0x16, 0xc0, 0x01, 0x80, 0x54, 0x04, 0x00, 0x08, 0x18, 0x40, 0x04, 0x8e,
  0x16, 0x00, 0x01, 0x80, 0x45, 0x04, 0x05, 0x00, 0x46, 0x44, 0xc5, 0x08,
  0x80, 0x04, 0x00, 0x04, 0xc0, 0x04, 0x00, 0x08, 0x5c, 0x44, 0x80, 0x01,
  0x9f, 0x42, 0xf1, 0x7f, 0x1e, 0x02, 0x00, 0x01, 0x04, 0x02, 0x00, 0x00,
  0x1e, 0x02, 0x00, 0x01, 0x1e, 0x00, 0x80, 0x00, 0x1d, 0x00, 0x00, 0x00,
  0x04, 0x05, 0x00, 0x00, 0x00, 0x74, 0x79, 0x70, 0x65, 0x00, 0x04, 0x07,
  0x00, 0x00, 0x00, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x00, 0x04, 0x06,
  0x00, 0x00, 0x00, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x00, 0x04, 0x27, 0x00,
  0x00, 0x00, 0x62, 0x61, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65,
  0x6e, 0x74, 0x20, 0x23, 0x31, 0x20, 0x28, 0x65, 0x78, 0x70, 0x65, 0x63,
  0x74, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2c, 0x20,
  0x67, 0x6f, 0x74, 0x20, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x29, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x27, 0x00,
  0x00, 0x00, 0x62, 0x61, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65,
  0x6e, 0x74, 0x20, 0x23, 0x32, 0x20, 0x28, 0x65, 0x78, 0x70, 0x65, 0x63,
  0x74, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2c, 0x20,
  0x67, 0x6f, 0x74, 0x20, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x62,
  0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00,
  0x62, 0x61, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74,
  0x20, 0x23, 0x33, 0x20, 0x28, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
  0x64, 0x20, 0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x2c, 0x20, 0x67,
  0x6f, 0x74, 0x20, 0x00, 0x04, 0x28, 0x00, 0x00, 0x00, 0x62, 0x61, 0x64,
  0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x23, 0x34,
  0x20, 0x28, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x62,
  0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x2c, 0x20, 0x67, 0x6f, 0x74, 0x20,
  0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,
  0x04, 0x05, 0x00, 0x00, 0x00, 0x66, 0x69, 0x6e, 0x64, 0x00, 0x04, 0x05,
  0x00, 0x00, 0x00, 0x5b, 0x2f, 0x5c, 0x5d, 0x00, 0x04, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x73, 0x75, 0x62, 0x00, 0x04,
  0x03, 0x00, 0x00, 0x00, 0x66, 0x73, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00,
  0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x65, 0x00, 0x04, 0x06, 0x00, 0x00,
  0x00, 0x69, 0x73, 0x44, 0x69, 0x72, 0x00, 0x04, 0x06, 0x00, 0x00, 0x00,
  0x74, 0x61, 0x62, 0x6c, 0x65, 0x00, 0x04, 0x07, 0x00, 0x00, 0x00, 0x69,
  0x6e, 0x73, 0x65, 0x72, 0x74, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x2e,
  0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x2e, 0x2e, 0x00, 0x04, 0x04, 0x00,
  0x00, 0x00, 0x2e, 0x2e, 0x2f, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x2e,
  0x2f, 0x00, 0x04, 0x05, 0x00, 0x00, 0x00, 0x6c, 0x69, 0x73, 0x74, 0x00,
  0x04, 0x02, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const unsigned int fs_complete_func_len = 1364;

static int fs_complete(lua_State *L) {
    lua_getfield(L, LUA_REGISTRYINDEX, "fs.complete");
    if (lua_isnil(L, -1)) {
        lua_pop(L, 1);
        luaL_loadbuffer(L, fs_complete_func, fs_complete_func_len, "=fs.complete");
        lua_newtable(L);
        lua_setupvalue(L, -2, 1);
        lua_pushvalue(L, -1);
        lua_setfield(L, LUA_REGISTRYINDEX, "fs.complete");
    }
    lua_insert(L, 1);
    lua_call(L, lua_gettop(L) - 1, LUA_MULTRET);
    return lua_gettop(L);
}

extern const luaL_Reg fs_lib[] = {
    {"list", fs_list},
    {"exists", fs_exists},
    {"isDir", fs_isDir},
    {"isReadOnly", fs_isReadOnly},
    {"getName", fs_getName},
    {"getDrive", fs_getDrive},
    {"getSize", fs_getSize},
    {"getFreeSpace", fs_getFreeSpace},
    {"makeDir", fs_makeDir},
    {"move", fs_move},
    {"copy", fs_copy},
    {"delete", fs_delete},
    {"combine", fs_combine},
    {"open", fs_open},
    {"find", fs_find},
    {"getDir", fs_getDir},
    {NULL, NULL}
};